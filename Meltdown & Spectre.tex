% TEMPLATE FOR SEMINARS
%
% This template serves as a basic style for your seminar paper. Please
% make yourself familiar with LaTeX, BibTeX and this template. Several
% parts of the template need to be adjusted, these places are marked
% with FIXME.
%
% Contact your advisor in case you have questions.

\documentclass[a4paper,oneside,openright] {scrreprt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx,color}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{fancyhdr}
\usepackage{times}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
%\usepackage{dtklogos}
%\usepackage{blindtext}
\usepackage{tikz}
%\usepackage{longtable}
%\usepackage{supertabular}
%\usepackage{verbatim}
%\usepackage{color}
%\usepackage{moreverb}       % z.B. \listinginput
%\usepackage{float}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\title{\Huge Meltdown \& Spectre}
\author{\Large Marvin Schirrmacher}

\makeatletter

%*** Commands you may want to use ***
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newenvironment{example}{\begin{quote}{\bf Example:}}{\end{quote}}

\begin{document}

\input{titlepage}

\pagestyle{plain}
\cleardoublepage
\pagenumbering{roman}
\tableofcontents
\clearpage
\pagenumbering{arabic}

%************************************************************%
%* START WRITING HERE OR PROVIDE SECTIONS IN SEPERATE FILES *%
%************************************************************%

%%%
\chapter{Overview}  
\label{ch:overview}
%%%

Meltdown and Spectre are the result of the most critical vulnerabilities in todays processors 
which threaten the modern world of computing. They allow reading secret data from other processes running on
the same machine and thereby circumventing the protection mechanisms of operating systems.
These exploits put hardware and software companies under pressure for finding short-term as well
as long-term solutions to address arising problems. To avoid debacles quick solutions have been found 
for some of the uncovered exploit techniques, but in the long run the fundamental design of modern 
processors has to be challenged and reconsidered.

\section{Meltdown and Spectre in Brief}
\label{ch:intro:motivation}

Meltdown and Spectre misuse a feature of modern processors which enables fast execution of machine instructions, 
called \textit{out-of-order execution}. This feature allows to force the CPU to execute instructions 
which read secret data from address spaces of other processes or even the kernel address space. 
Even though the processors behave correctly by cleaning or vanishing illegally accessed data, 
they still leave traces which enable to build so called \textit{covert channels} 
and thus leveraging attacks likes Meltdown and Spectre.

\section{Relevance and Practical Impact}
\label{ch:intro:motivation}

Especially the rise of cloud computing accelerates the urgency for solving Meltdown and Spectre related issues.
Companies which run their software in the cloud became vulnerable because the exploit techniques enable attackers
to read private data of customers by running malicious software on the same machines. 

Also applications running on mobile phones or laptops are vulnerable and expose their sensitive data. 
Even browsers can easily be attacked with a short JavaScript implementation of Spectre and thus reveal secret data
like passwords, session keys or cookies from websites. These examples indicate that Meltdown and Spectre are a serious matter which should be dealt with.

This work introduces all basics needed to understand Meltdown and Spectre and also dives deeper into the implementation
to focus on technical details of the exploits. At the end the reader should have a deep understanding of Meltdown and Spectre
and should be able to distinguish their traits and impact on modern computing.

%%%
\chapter{Computer Architecture Basics}
\label{ch:basics}
%%%

This chapter introduces some basics which are needed to understand and create implementations of Meltdown and Spectre. 
All parts of this chapter are presented isolated and not in the context of the exploits. 
Rather their connection and purpose is highlighted in chapters 3 and 4.

\section{Processes, Address Spaces and Caching}
\label{ch:intro:motivation}

Operating systems use processes as an abstraction to handle execution of multiple programs at the same time
 and managing their associated resources like address spaces, registers, list of open files, 
 out-standing alarms and lists of related processes ~\cite{tanenbaum2009modern:39-41}. 
CPU hardware ensures that processes of the operating system, \textit{kernel processes},  and processes of users are protected from each other 
by generating isolated address spaces for each process 
and preventing mutual modification or illegal access of data ~\cite{silberschatz2012operating}.

Every illegal operation of a process trying to circumvent these isolation boundaries results in a 
fatal error, called \textit{trap}, which must be handled by the operating system. Memory separation is realized 
with the help of \textit{virtual address spaces} which are further divided into fixed-size \textit{pages} 
which are mapped into \textit{physical address space} by page tables ~\cite{hennessy2011computer:105-107}. 
A page table knows which process is allowed to access a specific page and thus it serves as
 a restriction mechanism to monitor and control illegal memory access.

The memory of a computer is divided into \textit{cache lines} which can be stored temporarily in the cache to accelerate
access of frequently used memory locations ~\cite{tanenbaum2009modern:24-27}. Because the size of a cache is limited
cache lines have to be evicted over time depending on their frequency of usage resulting in a \textit{cache hit} if a line
is cached, otherwise in a \textit{cache miss}. If a cache miss occurs the processor has to load data from another
cache or from memory which delays data access by a significant amount of time.

\section{Out-of-order Execution}
\label{ch:intro:motivation}

Tomasulo ~\cite{tomasulo1967efficient} created an algorithm which analyses a set or \textit{window} of
program instructions and their relationships to maximize their overlapping capabilities and thus the ability to get parallelized 
without harming essential precedences. This allows processors to reorganize instructions so that their execution is faster 
in comparison to the execution time with the original order.
Succeeding instructions can be executed in parallel if preceding ones
 have to wait for accessing memory in case of a cache miss~\cite{hennessy2011computer:183}.

\section{Branch Prediction}
\label{ch:intro:branch_prediction}

Branch prediction is a feature of processors used to guess the result of a conditional branch in a sequence of program instructions to gain performance boosts~\cite{smith1995microarchitecture}.
So called \textit{branch predictors} analyse static information, e.g. opcode types, or dynamic program information, e.g. the branch history, to predict the result of these conditional branches.
The prediction decides if the instructions following the branch condition should be executed or not.
If the guess is correct performance improvements are gained because following statements can be executed in advance 
while the condition is evaluated.

\section{Transient Instructions}
\label{ch:intro:branch_prediction}

As already mentioned above out-of-order execution reorders program instructions to accelerate CPU performance.
If an instruction is mistakenly executed in advance, e.g. when a branch condition is predicted incorrectly by the branch predictor, 
then the speculatively executed instruction is called a \textit{transient instruction} ~\cite{lipp2018meltdown, kocher2018spectre}.
When the CPU detects that a transient instruction was executed it inverts its effects by dismissing results and resetting the state of affected registers.
We will see in Chapter 3 that modern processors do not remove all traces of such transient instructions and thus enable
Meltdown and Spectre attacks.

This Chapter introduced some fundamentals which are needed for understanding Meltdown and Spectre as well as their 
effects on the architectural state of the CPU and the operating system. The next Chapter will show how these parts
are connected in the context of the exploits.

%%%
\chapter{Meltdown versus Spectre}
\label{ch:contentI}
%%%

The following chapter deals with the common features and differences of Meltdown and Spectre based on the
 original papers ~\cite{lipp2018meltdown, kocher2018spectre}. This chapter highlights why the exploits are related
 and shows how they use different techniques to achieve their goals.
 
 
 \section{Differences in Brief}
 \label{ch:intro:motivation}
 
 Meltdown and Spectre both misuse out-of-order execution and transient instructions as techniques to access memory of 
 other processes by analyzing side channel information of the CPU's cache. 
  Meltdown enables an attacker to read memory of kernel and user processes
  in contrast to Spectre which just allows to dump memory of user processes. Spectre affects all modern processors like Intel, AMD, and ARM while Meltdown
 is only exploitable on Intel processors. The challenge of Spectre is that it has to be adapted for specific programs under attack. 
 Meltdown on the other hand is a more general approach with regard to its implementation. The following sections compare Meltdown and Spectre in depth.
 
\section{What Unites Them?}
\label{ch:intro:motivation}

This section deals with the common features of Meltdown and Spectre in detail. 
Both attacks use out-of-order execution and transient instructions to manipulate the cache of a CPU and thereby
creating so called \textit{covert channels} to reveal secret data. Although they apply different techniques to 
manipulate the cache, as we will see in chapter 3.3, both attacks misuse the design of modern processors
by analyzing traces of \textit{microarchitectural state} changes. 

\subsection{Usage of Transient Instructions}
\label{ch:intro:motivation:A}

When a transient instruction is executed the microarchitectural state of a CPU is altered, e.g. registers are filled with results
of the instruction. When the CPU detects that the speculatively executed instruction should not have been executed it cleans these state
changes as already mentioned. So from the outer architectural view processors behave correctly. 
Despite modern processors do not eliminate all microarchitectural state changes properly so that the execution of a transient instruction
 leaves a persistent trace. In the case of Meltdown and Spectre the cache is altered with speculatively executed instructions resulting
 in a microarchitectural state change which is not vanished by modern CPUs.

 \subsection{Building Covert Channels}
\label{ch:intro:motivation:A}

Side-channel attacks use physical channels like power consumption or timing behavior of programs to
leak secret data. Meltdown and Spectre are side-channel attacks, more precisely \textit{cache attacks}, 
utilizing the timing behavior of the cache ~\cite{osvik2006cache}.

The core idea of the attacks is to execute transient instructions which access data of their own address space
 but interweave the access location with an unknown secret byte from another process. 
 When the CPU loads the secret byte to dynamically calculate the target memory location 
it detects that the instruction is transient and vanishes the secret byte and the result of the final memory location from its state. 
Though the access instruction was executed in advance, before the CPU detects that it is transient, the microarchitectural state
 of the CPU is already altered.
 Since memory locations are cached when being read and the processor does not clean its microarchitectural state properly.
 Now we just have to detect which memory location has been cached to recreate the secret byte.
 Meltdown and Spectre instrumenting techniques like Flush+Reload ~\cite{yarom2014flush} 
 or Evict+Reload ~\cite{gruss2015cache} which analyze the timing behavior of accessing each element of the array 
 to find out which element has been cached.
 So the cache acts as a covert channel making the inner workings of the CPU visible to the outside world.

\subsection{Process of Revealing Secret Data}
\label{ch:intro:motivation:A}

Meltdown and Spectre exploit the execution of transient instructions by accessing bytes of address spaces 
from other processes which are usually protected by the CPU and the operating system. 

For revealing a secret byte an array with as many elements as the size of a byte has to be initialized in the attackers address space. 
The next step is to load an element of the array from a position which depends on the secret byte. 
More precisely the target access location is calculated by adding the secret byte to the starting position of the array and
 thus it represents the offset of the target element which will be accessed. As mentioned earlier elements accessed within the transient
 instruction will be cached when being read by the processor. 
 Besides a cached element is loaded significantly faster into a register of the CPU than accessed from memory.
 
If we check every element of the array for being cached with the techniques mentioned above we reveal the secret byte 
 because it is equal to the position of the accessed element.
This process can be executed iteratively to reveal the whole address space of other processes. 
In chapter 4 this process is examined in detail with the help of the implementation of both attacks.

This chapter highlighted the common techniques of Meltdown and Spectre and how they can be used to reveal secret bytes from other
processes. The next chapter will focus on the differences of the exploits.

\section{What Divides Them?}
\label{ch:intro:motivation}

This chapter deals with the differences of Meltdown and Spectre. As mentioned above Meltdown enables an attacker 
to dump the memory of kernel and user processes. On the other hand Spectre can just be utilized to read memory of user processes.
Adding to this the implementation of Spectre is more specific because it requires adaptation to the attacked process 
, e.g. by analyzing the binaries a program uses. Meltdown is a more general approach with the limitation that it just works on Intel
 processors in contrast to Spectre which is applicable on all modern processors like Intel, AMD, and ARM. Furthermore Meltdown and 
 Spectre use different implementation details regarding the usage of transient instructions. 
 All these details will be examined in the following.

\subsection{Dealing with Exceptions}
\label{ch:intro:motivation:A}

As explained above Meltdown and Spectre try to manipulate the cache with the help of transient instructions. 
When a CPU detects illegal memory access within such instructions a fatal error is raised and the program of the attacker
is terminated. Therefore Meltdown has two concepts of avoiding crashes: \textit{exception handling} and \textit{exception suppression}.

Exception handling is the process of catching the error. Meltdown uses two techniques to catch errors: defining signal handlers
which are executed in case of a segmentation fault or by creating child processes which are rolled back on error.
The latter is just applicable to Intel TSX processors where transient instructions can be grouped and reversed a whole after failing.

Exception suppression is the process of preventing that an error is raised. This can be done by putting the illegal memory access
within a branch condition. The goal is to trick the branch predictor so that the condition evaluates to be true.
Then the transient instruction is executed without raising an error and silently vanished when the CPU detects that the branch
condition was falsely evaluated but still leaving exploitable traces in the cache.

Spectre just utilizes the mistraining of the branch predictor so the exploit is only based on exception suppression.

\subsection{Adaptability}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

%%%
\chapter{Source Code Analysis}
\label{ch:sourceCodeAnalysis}
%%%

XXXXXXXXXXXXXXXXXXXX
\footnote{https://github.com/IAIK/meltdown/tree/master/libkdump}
XXXXXXXXXXXXXXXXXXXX

\section{Meltdown Implementation}
\label{ch:intro:motivation}

XXXXXXXXXXXXXXXXXXXX


\subsection{Transient Assembler Instructions}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

\subsection{Exception Suppression}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

\subsection{Detecting Cached Bytes}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

\subsection{Retrieving Secret Bytes}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

\section{Spectre Implementation}
\label{ch:intro:motivation}

XXXXXXXXXXXXXXXXXXXX

\subsection{Detecting Cached Bytes}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

\subsection{Mistraining the Branch Predictor}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

\subsection{Retrieving Secret Bytes}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

%%%
\chapter{Countermeasures}
\label{ch:countermeasures}
%%%

XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX

\section{Meltdown}
\label{ch:intro:motivation}

\section{Spectre}
\label{ch:intro:motivation}


%%%
\chapter{Conclusion}
\label{ch:conclusion}
%%%

XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX

\bibliography{literature}
\bibliographystyle{alpha}

\end{document}
